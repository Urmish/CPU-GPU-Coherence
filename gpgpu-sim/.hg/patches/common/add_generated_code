# HG changeset patch
# Parent 4d53a3be2ced4df6a1538229a25cedd6b0e16f5d
# User Joel Hestness <jthestness@gmail.com>
Add GPGPU-Sim 3.2.2 Generated Code

As a step toward making GPGPU-Sim more plug-and-play, move the generated code
from being part of the UW GPGPU-Sim repository and make it part of the patches.
With this change, users can now check out GPGPU-Sim from the UBC git repo,
update it to the correct version, pull UW GPGPU-Sim patches and apply, and
build gem5-gpu.

diff --git a/cuda-sim/instructions.h b/cuda-sim/instructions.h
new file mode 100644
--- /dev/null
+++ b/cuda-sim/instructions.h
@@ -0,0 +1,95 @@
+// DO NOT EDIT THIS FILE! IT IS AUTOMATICALLY GENERATED BY THE MAKEFILE (see target for instructions.h)
+#include "ptx_ir.h"
+#ifndef instructions_h_included
+#define instructions_h_included
+void abs_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void addp_impl( const ptx_instruction *pI, ptx_thread_info *thread );
+void add_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void addc_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void and_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void andn_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void atom_impl( const ptx_instruction *pI, ptx_thread_info *thread );
+void bar_sync_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void bfe_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void bfi_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void bfind_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void bra_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void brx_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void break_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void breakaddr_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void brev_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void brkpt_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void call_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void callp_impl( const ptx_instruction *pI, ptx_thread_info *thread );
+void clz_impl( const ptx_instruction *pI, ptx_thread_info *thread );
+void cnot_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void cos_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void cvt_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void cvta_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void div_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void ex2_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void exit_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void fma_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void isspacep_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void ld_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void ldu_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void lg2_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void mad24_impl( const ptx_instruction *pI, ptx_thread_info *thread );
+void mad_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void madp_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void max_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void membar_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void min_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void mov_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void mul24_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void mul_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void neg_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void nandn_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void norn_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void not_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void or_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void orn_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void pmevent_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void popc_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void prefetch_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void prefetchu_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void prmt_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void rcp_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void red_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void rem_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void ret_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void retp_impl( const ptx_instruction *pI, ptx_thread_info *thread );
+void rsqrt_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void sad_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void selp_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void setp_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void set_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void shl_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void shr_impl( const ptx_instruction *pI, ptx_thread_info *thread );
+void sin_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void slct_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void sqrt_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void ssy_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void st_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void sub_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void nop_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void subc_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void suld_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void sured_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void sust_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void suq_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void tex_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void txq_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void trap_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void vabsdiff_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void vadd_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void vmad_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void vmax_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void vmin_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void vset_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void vshl_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void vshr_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void vsub_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void vote_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+void xor_impl( const ptx_instruction *pI, ptx_thread_info *thread ) ;
+#endif
diff --git a/cuda-sim/lex.ptx_.c b/cuda-sim/lex.ptx_.c
new file mode 100644
--- /dev/null
+++ b/cuda-sim/lex.ptx_.c
@@ -0,0 +1,4120 @@
+#line 2 "lex.ptx_.c"
+
+#line 4 "lex.ptx_.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer ptx__create_buffer
+#define yy_delete_buffer ptx__delete_buffer
+#define yy_flex_debug ptx__flex_debug
+#define yy_init_buffer ptx__init_buffer
+#define yy_flush_buffer ptx__flush_buffer
+#define yy_load_buffer_state ptx__load_buffer_state
+#define yy_switch_to_buffer ptx__switch_to_buffer
+#define yyin ptx_in
+#define yyleng ptx_leng
+#define yylex ptx_lex
+#define yylineno ptx_lineno
+#define yyout ptx_out
+#define yyrestart ptx_restart
+#define yytext ptx_text
+#define yywrap ptx_wrap
+#define yyalloc ptx_alloc
+#define yyrealloc ptx_realloc
+#define yyfree ptx_free
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE ptx_restart(ptx_in  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int ptx_leng;
+
+extern FILE *ptx_in, *ptx_out;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
+     *       access to the local variable yy_act. Since yyless() is a macro, it would break
+     *       existing scanners that call yyless() from OUTSIDE ptx_lex. 
+     *       One obvious solution it to make yy_act a global. I tried that, and saw
+     *       a 5% performance hit in a non-ptx_lineno scanner, because yy_act is
+     *       normally declared as a register variable-- so it is not worth it.
+     */
+    #define  YY_LESS_LINENO(n) \
+            do { \
+                int yyl;\
+                for ( yyl = n; yyl < ptx_leng; ++yyl )\
+                    if ( ptx_text[yyl] == '\n' )\
+                        --ptx_lineno;\
+            }while(0)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up ptx_text. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up ptx_text again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via ptx_restart()), so that the user can continue scanning by
+	 * just pointing ptx_in at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when ptx_text is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int ptx_leng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow ptx_wrap()'s to do buffer switches
+ * instead of setting up a fresh ptx_in.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void ptx_restart (FILE *input_file  );
+void ptx__switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE ptx__create_buffer (FILE *file,int size  );
+void ptx__delete_buffer (YY_BUFFER_STATE b  );
+void ptx__flush_buffer (YY_BUFFER_STATE b  );
+void ptx_push_buffer_state (YY_BUFFER_STATE new_buffer  );
+void ptx_pop_buffer_state (void );
+
+static void ptx_ensure_buffer_stack (void );
+static void ptx__load_buffer_state (void );
+static void ptx__init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER ptx__flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE ptx__scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE ptx__scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE ptx__scan_bytes (yyconst char *bytes,int len  );
+
+void *ptx_alloc (yy_size_t  );
+void *ptx_realloc (void *,yy_size_t  );
+void ptx_free (void *  );
+
+#define yy_new_buffer ptx__create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        ptx_ensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ptx__create_buffer(ptx_in,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        ptx_ensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ptx__create_buffer(ptx_in,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define ptx_wrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *ptx_in = (FILE *) 0, *ptx_out = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int ptx_lineno;
+
+int ptx_lineno = 1;
+
+extern char *ptx_text;
+#define yytext_ptr ptx_text
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up ptx_text.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	ptx_leng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 289
+#define YY_END_OF_BUFFER 290
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[1289] =
+    {   0,
+        0,    0,  286,  286,    0,    0,    0,    0,    0,    0,
+      290,  288,  276,  274,  275,  268,  284,  288,  288,  264,
+      265,  256,  257,  255,  271,  272,  155,  155,  266,  267,
+      262,  269,  263,  258,  149,  149,  260,  261,  149,  149,
+      149,  149,  149,  149,  149,  149,  149,  149,  149,  149,
+      149,  149,  149,  149,  149,  278,  259,  270,  286,  286,
+      285,  286,  286,  286,  286,  286,  286,  286,  286,  286,
+      286,  286,  286,  286,  286,  286,  286,  286,  281,  281,
+      283,  282,  281,  281,  281,  281,  281,  281,  281,  281,
+      281,  281,  281,  281,  281,  281,  281,  281,  281,  272,
+
+      277,    0,  274,  150,  150,  150,  150,  150,  150,  150,
+      150,  150,  150,  150,  155,  249,  250,  251,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,  252,
+      253,  254,  279,  273,    0,  153,  155,    0,    0,    0,
+      155,    0,  149,  149,  149,  149,  149,  149,  149,  149,
+      149,  149,  149,  149,  149,  149,  149,  149,  149,  149,
+       28,  149,  149,  149,  149,  149,  149,  149,  149,  149,
+       45,  149,  149,  149,  149,  149,  149,  149,  149,  149,
+      149,  149,  149,  149,   68,  149,  149,  149,  149,  149,
+
+      149,  149,  149,  149,  286,  286,  286,  286,  286,  286,
+      286,  286,  286,  286,  286,  286,  286,  286,  286,  286,
+      286,  286,   28,  286,  286,  286,  286,  286,  286,  286,
+      286,  286,   45,  286,  286,  286,  286,  286,  286,  286,
+      286,  286,  286,  286,  286,  286,   68,  286,  286,  286,
+      286,  286,  286,  286,  286,  286,  281,  281,  280,  281,
+      281,  281,  281,  281,  281,  281,  281,  281,  281,  281,
+      281,  281,  281,  281,  281,   28,  281,  281,  281,  281,
+      281,  281,  281,  281,  281,   45,  281,  281,  281,  281,
+      281,  281,  281,  281,  281,  281,  281,  281,  281,   68,
+
+      281,  281,  281,  281,  281,  281,  281,  281,  281,    0,
+      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
+      150,  150,  150,  150,  246,  247,  248,    0,    0,    0,
+        0,    0,    0,    0,    0,  170,    0,    0,    0,    0,
+      229,  199,  230,    0,  231,    0,  233,    0,    0,  193,
+        0,    0,    0,    0,    0,    0,    0,    0,  198,  223,
+      197,    0,  204,  205,    0,  196,  202,  203,  195,  232,
+        0,    0,    0,  194,    0,    0,  237,    0,    0,    0,
+        0,  212,  210,  213,  211,    0,    0,    0,  158,    0,
+        0,  200,    0,    0,    0,    0,    0,    0,    0,  228,
+
+        0,    0,    0,  162,    0,  180,  181,  182,    0,    0,
+      234,    0,  235,    0,  273,  151,  153,  154,    0,    0,
+      152,  149,    1,    2,    5,  149,  149,    9,   10,   12,
+      149,  149,   13,  149,   18,  149,   20,   21,   23,   24,
+      149,   26,  149,    0,  149,   30,   31,   33,   35,  149,
+       37,   38,   40,  149,   41,   90,  149,   44,   46,  149,
+      149,  149,  149,   52,   53,   54,   55,  149,   58,  149,
+       61,   62,   63,   64,  149,  149,   67,    0,  149,   70,
+      149,   75,  149,   76,  149,   77,  149,  149,  149,  149,
+      149,  149,  149,  149,   89,  286,    1,    2,    5,  286,
+
+      286,    9,   10,   12,  286,  286,   13,  286,   18,  286,
+       20,   21,   23,   24,  286,   26,  286,  286,   30,   31,
+       33,   35,  286,   37,   38,   40,  286,   41,   90,  286,
+       44,   46,  286,  286,  286,  286,   52,   53,   54,   55,
+      286,   58,  286,   61,   62,   63,   64,  286,  286,   67,
+      286,   70,  286,   75,  286,   76,  286,   77,  286,  286,
+      286,  286,  286,  286,  286,  286,   89,  281,    1,    2,
+        5,  281,  281,    9,   10,   12,  281,  281,   13,  281,
+       18,  281,   20,   21,   23,   24,  281,   26,  281,  281,
+       30,   31,   33,   35,  281,   37,   38,   40,  281,   41,
+
+       90,  281,   44,   46,  281,  281,  281,  281,   52,   53,
+       54,   55,  281,   58,  281,   61,   62,   63,   64,  281,
+      281,   67,  281,   70,  281,   75,  281,   76,  281,   77,
+      281,  281,  281,  281,  281,  281,  281,  281,   89,    0,
+      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
+      144,  150,  146,  150,  227,  241,    0,  221,  236,  220,
+        0,  171,  172,  173,    0,    0,    0,    0,    0,    0,
+      239,    0,  224,  243,    0,  184,    0,    0,    0,  166,
+      167,  168,    0,    0,  214,    0,    0,  189,    0,  188,
+        0,  242,  187,  106,  186,  245,  244,  191,  215,  185,
+
+      201,  190,    0,    0,    0,  127,  113,    0,  208,  206,
+      209,  207,  159,  160,  161,    0,  192,    0,    0,    0,
+        0,    0,  225,    0,  121,  163,  164,  165,  217,    0,
+        0,    0,  238,  154,    0,    0,  152,  149,    4,    3,
+        6,    7,    0,  149,  149,  149,   14,  149,   16,   19,
+       22,   25,  149,    0,  149,  149,   34,  149,  149,  149,
+       43,  149,   48,  149,   51,   56,  149,   59,   60,   65,
+       66,    0,  149,   71,   72,  149,  149,   78,  149,   80,
+       81,   82,   83,   88,   84,   85,   86,   87,  286,    4,
+        3,    6,    7,  286,  286,  286,   14,  286,   16,   19,
+
+       22,   25,  286,  286,  286,   34,  286,  286,  286,   43,
+      286,   48,  286,   51,   56,  286,   59,   60,   65,   66,
+      286,   71,   72,  286,  286,   78,  286,   80,   81,   82,
+       83,   88,   84,   85,   86,   87,  281,    4,    3,    6,
+        7,  281,  281,  281,   14,  281,   16,   19,   22,   25,
+      281,  281,  281,   34,  281,  281,  281,   43,  281,   48,
+      281,   51,   56,  281,   59,   60,   65,   66,  281,   71,
+       72,  281,  281,   78,  281,   80,   81,   82,   83,   88,
+       84,   85,   86,   87,    0,  150,  150,  150,  150,  150,
+      150,  150,  150,  141,  150,  145,  150,    0,    0,    0,
+
+        0,    0,  174,    0,   95,    0,    0,    0,  240,  226,
+        0,  169,  102,  219,  103,    0,  183,    0,    0,    0,
+        0,    0,  176,    0,    0,    0,    0,  117,    0,  119,
+        0,    0,    0,    0,    0,  216,    0,    0,  149,    0,
+      149,   11,   91,   15,   17,  149,    0,  149,   32,  149,
+       39,   42,  149,  149,   57,    0,  149,   73,   74,  149,
+      286,  286,   11,   91,   15,   17,  286,  286,   32,  286,
+       39,   42,  286,  286,   57,  286,   73,   74,  286,  281,
+      281,   11,   91,   15,   17,  281,  281,   32,  281,   39,
+       42,  281,  281,   57,  281,   73,   74,  281,    0,  128,
+
+      131,  150,  150,  150,  150,  150,  150,  142,  150,  150,
+        0,   93,    0,    0,  175,    0,    0,    0,   99,  100,
+        0,    0,  105,    0,    0,    0,    0,  111,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,  122,    0,    0,
+        0,    0,  149,    0,  149,  149,  149,    0,  149,   36,
+      149,  149,    0,  149,  149,  286,  286,  286,  286,  286,
+       36,  286,  286,  286,  286,  281,  281,  281,  281,  281,
+       36,  281,  281,  281,  281,    0,  150,  150,  133,  150,
+      134,  150,  140,  150,  147,    0,  218,  222,    0,    0,
+        0,    0,    0,  101,  104,    0,    0,    0,    0,  112,
+
+        0,    0,    0,  116,  118,    0,  120,  177,    0,    0,
+        0,    0,  148,    0,  149,  149,  149,    0,  149,   47,
+      149,    0,  149,  149,  286,  286,  286,  286,  286,   47,
+      286,  286,  286,  281,  281,  281,  281,  281,   47,  281,
+      281,  281,    0,  130,  132,  150,  150,  143,    0,    0,
+        0,    0,    0,    0,    0,  108,  109,    0,  114,    0,
+      115,  179,  123,  124,    0,    0,    8,    8,  149,   27,
+        0,  149,   49,    0,  149,   79,  286,    8,  286,   27,
+      286,   49,  286,   79,  281,    8,  281,   27,  281,   49,
+      281,   79,    0,  287,  150,  150,    0,    0,    0,    0,
+
+       98,  126,    0,    0,    0,    0,    0,   92,    0,  149,
+       50,    0,  149,  286,  286,   92,  286,   50,  286,  281,
+       92,  281,   50,  281,  129,  150,    0,    0,    0,    0,
+        0,    0,    0,    0,  156,    0,  149,    0,  149,  286,
+      286,  281,  281,  150,  150,  150,    0,    0,    0,    0,
+        0,    0,  178,    0,   29,   29,   69,   69,   29,   69,
+       29,   69,  135,  138,  139,  136,  137,    0,    0,    0,
+       97,    0,    0,    0,  125,    0,    0,  107,  110,    0,
+       94,   96,    0,    0,    0,    0,  157,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    4,    5,    6,    1,    7,    8,    1,    1,    9,
+       10,   11,   12,   13,   14,   15,   16,   17,   18,   19,
+       20,   21,   22,   23,   22,   24,   25,   26,   27,   28,
+       29,   30,    1,   31,   32,   33,   34,   35,   34,   36,
+       37,   37,   37,   37,   37,   37,   37,   37,   37,   38,
+       37,   39,   40,   37,   41,   37,   42,   43,   37,   44,
+       45,    1,   46,    1,   47,    1,   48,   49,   50,   51,
+
+       52,   53,   54,   55,   56,   37,   57,   58,   59,   60,
+       61,   62,   63,   64,   65,   66,   67,   68,   69,   70,
+       71,   72,   73,   74,   75,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[76] =
+    {   0,
+        1,    1,    2,    1,    1,    3,    4,    1,    1,    1,
+        5,    1,    1,    1,    1,    1,    6,    6,    6,    6,
+        6,    6,    6,    6,    6,    1,    1,    1,    1,    1,
+        1,    6,    6,    6,    6,    6,    4,    4,    4,    4,
+        4,    4,    4,    4,    1,    1,    4,    6,    6,    6,
+        6,    6,    6,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    1,    1,    1
+    } ;
+
+static yyconst flex_int16_t yy_base[1334] =
+    {   0,
+        0,    0,   74,  143,  212,  281,  346,    0, 1583, 1582,
+     1654, 1657, 1622,    0, 1657, 1657, 1657,    0,   27, 1657,
+     1657, 1657, 1657,   80,  403,   67,  461,   96, 1657, 1657,
+     1657, 1657, 1657, 1657,    0, 1620, 1657, 1657,   92,   42,
+       99, 1595, 1580, 1590, 1583,   37,  113,  102, 1583,   48,
+      101,  120,  118,  168, 1585, 1657, 1657, 1657,    0, 1614,
+     1657,  113,  136,  164, 1588, 1573, 1583, 1576,   77,  178,
+      129, 1576,  176,  186,  233,  179,  193, 1578,    0, 1607,
+     1657, 1621,  193,  202,  245, 1580, 1565, 1575, 1568,  166,
+      256,  158, 1568,  250,  245,  302,  205,  259, 1570, 1614,
+
+     1657, 1598,    0,    0,   28, 1568, 1563, 1578, 1577,  305,
+     1565, 1564, 1566, 1573,  359, 1657, 1569, 1568, 1567,  366,
+      469,  377, 1565,  158,  483,  269,  288, 1556,  383,  100,
+      457, 1551,  300,  475,  533,  267,  367,  509,  307, 1553,
+     1657, 1657, 1657,    0,  549,  588,  599,  180,    0,    0,
+     1657,    0,    0, 1574, 1547, 1560, 1559, 1548, 1544,  234,
+      443, 1549, 1534, 1544, 1539, 1537, 1534,  260, 1553, 1535,
+      640, 1580,   59, 1539, 1537, 1528, 1537, 1534, 1539,  370,
+     1532, 1539, 1528,  235, 1527,  457, 1525, 1536,  190,  328,
+     1526, 1535, 1520, 1512,  715,  462, 1512, 1533, 1517,  310,
+
+      345, 1513,  491, 1514,    0, 1546, 1511, 1524, 1523, 1512,
+     1508,  270,  507, 1513, 1498, 1508, 1503, 1501, 1498,  282,
+     1517, 1499,  535, 1544,  367, 1503, 1501, 1492, 1501, 1498,
+     1503,  514, 1496, 1503, 1492,  381, 1491,  524, 1489, 1500,
+      381,  345, 1490, 1499, 1484, 1476,  369,  614, 1476, 1497,
+     1481,  439,  451, 1477,  493, 1478,    0, 1510, 1657, 1475,
+     1488, 1487, 1476, 1472,  463,  627, 1477, 1462, 1472, 1467,
+     1465, 1462,  410, 1481, 1463,  235, 1508,  390, 1467, 1465,
+     1456, 1465, 1462, 1467,  525, 1460, 1467, 1456,  542, 1455,
+      577, 1453, 1464,  486,  534, 1454, 1463, 1448, 1440, 1499,
+
+      624, 1439, 1460, 1444,  533,  506, 1440,  580, 1441, 1469,
+     1442, 1454, 1433, 1444, 1441, 1438, 1431, 1437, 1439, 1446,
+      640, 1437, 1441, 1427, 1657, 1657, 1657, 1425, 1438,  537,
+      196, 1426, 1464, 1467, 1464, 1657, 1426,  607, 1435, 1416,
+      568, 1657, 1657, 1421, 1657, 1432, 1657, 1429, 1412, 1410,
+      624, 1453, 1456, 1453, 1450, 1414, 1399,  579, 1403, 1408,
+     1401, 1409, 1657, 1657, 1416, 1398, 1414, 1657, 1396, 1657,
+     1392, 1401, 1400,  622, 1406, 1399, 1657, 1393,  579, 1392,
+       92, 1399, 1398, 1397, 1396, 1428, 1431, 1428, 1657,  632,
+     1398, 1657, 1399, 1394, 1381, 1380, 1378, 1378, 1371, 1657,
+
+     1417, 1420, 1417, 1657, 1381, 1657, 1657, 1657, 1372, 1370,
+     1657, 1383, 1657, 1369,    0,  715, 1657,  677,    0,    0,
+     1391, 1393,    0,  631, 1370, 1370,  790,    0, 1368,    0,
+      635, 1365,    0, 1368,    0, 1359,    0, 1376,    0,    0,
+     1357,    0, 1360, 1353, 1352, 1351,    0,  642,    0, 1369,
+        0,    0, 1398, 1365,    0,    0, 1355,    0,    0, 1346,
+     1363, 1359, 1345,    0,    0,    0, 1348, 1345,    0, 1346,
+     1345,    0,    0,    0, 1340, 1339,    0, 1336, 1335, 1352,
+     1350,    0,  640,    0, 1338,    0, 1334, 1347,  545, 1337,
+     1344, 1329,  638, 1345,    0, 1358,    0,  649, 1332, 1332,
+
+      659,    0, 1330,    0,  699, 1327,    0, 1330,    0, 1321,
+        0, 1338,    0,    0, 1319,    0, 1322, 1315, 1314,    0,
+      687,    0, 1332,    0,    0, 1361, 1328,    0,    0, 1318,
+        0,    0, 1309, 1326, 1322, 1308,    0,    0,    0, 1311,
+     1308,    0, 1309, 1308,    0,    0,    0, 1303, 1302,    0,
+     1299, 1316, 1314,    0,  657,    0, 1302,    0, 1298, 1311,
+      699, 1301, 1308, 1293,  690, 1309,    0, 1322,    0,  650,
+     1296, 1296, 1343,    0, 1293,    0,  703, 1290,    0, 1293,
+        0, 1284,    0, 1301,    0,    0, 1282,    0, 1285, 1278,
+     1277,    0,  691,    0, 1295,    0,    0, 1324, 1291,    0,
+
+        0, 1281,    0,    0, 1272, 1289, 1285, 1271,    0,    0,
+        0, 1274, 1271,    0, 1272, 1271,    0,    0,    0, 1266,
+     1265,    0, 1262, 1279, 1277,    0,  700,    0, 1265,    0,
+     1261, 1274,  704, 1264, 1271, 1256,  698, 1272,    0, 1278,
+     1269, 1262, 1253, 1265, 1262, 1262, 1265, 1256, 1260, 1246,
+        0, 1258,    0, 1246, 1657, 1243, 1252, 1657, 1657, 1657,
+     1241, 1657, 1657, 1657, 1246, 1284, 1281, 1241, 1248, 1241,
+     1657, 1233, 1657, 1657, 1233, 1657, 1241, 1229, 1242, 1657,
+     1657, 1657, 1272, 1240, 1657, 1233, 1240, 1657, 1240, 1657,
+     1235, 1657, 1657, 1239, 1657, 1226, 1225, 1657, 1657, 1657,
+
+     1657, 1657, 1236, 1229, 1231, 1657, 1657, 1221, 1657, 1657,
+     1657, 1657, 1657, 1657, 1657, 1218, 1657, 1213, 1214, 1223,
+     1209, 1222, 1657, 1220, 1209, 1657, 1657, 1657, 1211, 1206,
+     1214, 1217, 1657, 1657,    0,    0, 1657, 1221,    0,    0,
+        0,    0, 1202, 1201, 1214, 1207,    0, 1197, 1200,    0,
+        0,    0, 1213, 1199, 1198, 1237,    0, 1209, 1235, 1195,
+        0, 1202,    0, 1201,    0,    0, 1186,    0,    0,    0,
+        0, 1190, 1189,    0,    0, 1198, 1182,    0, 1196,    0,
+        0,    0,    0,    0,    0,    0,    0,    0, 1204,    0,
+        0,    0,    0, 1180, 1193, 1186,    0, 1176, 1179,    0,
+
+        0,    0, 1192, 1178, 1217,    0, 1189, 1215, 1175,    0,
+     1182,    0, 1181,    0,    0, 1166,    0,    0,    0,    0,
+     1170,    0,    0, 1179, 1163,    0, 1177,    0,    0,    0,
+        0,    0,    0,    0,    0,    0, 1185,    0,    0,    0,
+        0, 1161, 1174, 1167,    0, 1157, 1160,    0,    0,    0,
+     1173, 1159, 1198,    0, 1170, 1196, 1156,    0, 1163,    0,
+     1162,    0,    0, 1147,    0,    0,    0,    0, 1151,    0,
+        0, 1160, 1144,    0, 1158,    0,    0,    0,    0,    0,
+        0,    0,    0,    0, 1176, 1150, 1155, 1153, 1148, 1153,
+      707, 1146, 1150,    0, 1138,    0, 1143, 1146, 1137, 1135,
+
+     1134, 1170, 1657, 1143, 1657,  572, 1126, 1120, 1657, 1657,
+     1126, 1657, 1657, 1657, 1657, 1141, 1657, 1130,  709, 1137,
+     1127, 1126, 1657, 1118, 1125, 1126, 1129, 1657, 1130, 1115,
+     1126, 1125, 1116, 1119, 1125, 1657,    0,    0, 1133, 1101,
+     1100,    0, 1122,    0,    0, 1119, 1110, 1109,    0, 1102,
+        0,    0, 1105, 1098,    0, 1105, 1104,    0,    0, 1105,
+     1128, 1088,    0, 1110,    0,    0,   34,   50,    0,  107,
+        0,    0,  265,  322,    0,  331,    0,    0,  357,  414,
+      406,    0,  450,    0,    0,  471,  474,    0,  478,    0,
+        0,  503,  513,    0,  606,    0,    0,  645,  669,  734,
+
+        0,  704,  713,  710,  719,  724,  725,    0,  721,  727,
+      714, 1657,  710,  715, 1657,  727,  719,  736,  748, 1657,
+      725,  728, 1657,  721,  745,  751,  742, 1657,  761,  755,
+      760,  752,  763,  749,  770,  757,  771, 1657,  764,  768,
+        0,    0,  783,  768,  769,  779,  779,  784,  785,    0,
+      768,  787,  790,  791,  787,  802,  782,  792,  792,  797,
+        0,  780,  797,  800,  796,  811,  791,  801,  801,  806,
+        0,  789,  806,  809,  805,  823,  839,  849,    0,  800,
+        0,  797,    0,  824,    0,  811, 1657, 1657,  811,  817,
+      815,  863,  823, 1657, 1657,  842,  837,  841,  845, 1657,
+
+      843,  831,  836, 1657, 1657,  844, 1657, 1657,  838,  847,
+        0,    0,    0,  850,  851,  851,  841,  838,  839,    0,
+      851,  841,  842,  856,  874,  861,  861,  851,  848,    0,
+      860,  850,  864,  882,  869,  869,  859,  856,    0,  868,
+      858,  872,  923,    0,  910,  886,  880,    0,  891,  891,
+      874,  887,  925,  887,  890, 1657, 1657,  891, 1657,  890,
+     1657, 1657, 1657, 1657,    0,    0, 1657,    0,  891,    0,
+      900,  901,  891,  903,  904,    0,  958,    0,  898,    0,
+      907,  898,  910,    0,  964,    0,  904,    0,  913,  903,
+      916,    0,  970, 1657,  917,  929,  912,  914,  918,  928,
+
+     1657, 1657,  929,  930,  931,    0,    0,    0,  926,  927,
+        0,  928,  929,  985,    0,    0,  931,    0,  932,  989,
+        0,  935,    0,  936,    0,  943,  940,  944,  933,  936,
+      939,  940,  952,    0, 1657,  954,  955,  956,  957,  958,
+      959,  960,  961,  951,  963,  964,  945,  966,  948,  955,
+      956,  957, 1657,    0, 1657,    0, 1657,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,  971,  958,  963,
+     1657,  967,  968,    0, 1657,  963,  979, 1657, 1657,    0,
+     1657, 1657,    0,    0,    0,    0, 1657, 1657, 1031, 1037,
+     1043, 1046, 1049, 1055, 1061, 1067, 1039, 1045, 1048, 1073,
+
+     1079, 1085, 1091, 1097, 1103, 1052, 1057, 1109, 1115, 1121,
+     1060, 1063, 1069, 1075, 1093, 1099, 1105, 1117, 1127, 1128,
+     1129, 1135, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148,
+     1149, 1150, 1151
+    } ;
+
+static yyconst flex_int16_t yy_def[1334] =
+    {   0,
+     1288,    1, 1289, 1289, 1290, 1290,    1,    7,    7,    7,
+     1288, 1288, 1288, 1291, 1288, 1288, 1288, 1292, 1292, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1293, 1293, 1288, 1288, 1293, 1293,
+     1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293,
+     1293, 1293, 1293, 1293, 1293, 1288, 1288, 1288, 1294, 1294,
+     1288, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1295, 1295,
+     1288, 1288, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295,
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1288,
+
+     1288, 1288, 1291, 1292, 1292, 1292, 1292, 1292, 1292, 1292,
+     1292, 1292, 1292, 1292, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1296, 1288, 1288, 1288, 1288, 1297, 1298,
+     1288, 1299, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293,
+     1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293,
+     1300, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293,
+     1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293,
+     1293, 1293, 1293, 1293, 1301, 1293, 1293, 1293, 1293, 1293,
+
+     1293, 1293, 1293, 1293, 1294, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1302, 1294, 1294, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1294, 1303, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1294, 1295, 1295, 1288, 1295,
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295,
+     1295, 1295, 1295, 1295, 1295, 1304, 1295, 1295, 1295, 1295,
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295,
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1305,
+
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1288,
+     1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292,
+     1292, 1292, 1292, 1292, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1296, 1288, 1288, 1288, 1306, 1307,
+     1299, 1293, 1293, 1293, 1293, 1293, 1308, 1293, 1293, 1293,
+     1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293,
+     1293, 1293, 1293, 1288, 1293, 1293, 1293, 1293, 1293, 1293,
+     1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293,
+     1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293,
+     1293, 1293, 1293, 1293, 1293, 1293, 1293, 1288, 1293, 1293,
+     1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293,
+     1293, 1293, 1293, 1293, 1293, 1294, 1294, 1294, 1294, 1294,
+
+     1309, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1295, 1295, 1295,
+     1295, 1295, 1310, 1295, 1295, 1295, 1295, 1295, 1295, 1295,
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295,
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295,
+
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295,
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295,
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295,
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1288,
+     1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292,
+     1292, 1292, 1292, 1292, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1311, 1312, 1288, 1293, 1293, 1293,
+     1293, 1293, 1288, 1293, 1293, 1293, 1293, 1293, 1293, 1293,
+     1293, 1293, 1293, 1288, 1293, 1293, 1293, 1293, 1293, 1293,
+     1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293,
+     1293, 1288, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293,
+     1293, 1293, 1293, 1293, 1293, 1293, 1293, 1293, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294,
+
+     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1294, 1295, 1295, 1295, 1295,
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295,
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295,
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295,
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295,
+     1295, 1295, 1295, 1295, 1288, 1292, 1292, 1292, 1292, 1292,
+     1292, 1292, 1292, 1292, 1292, 1292, 1292, 1288, 1288, 1288,
+
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1313, 1314, 1293, 1288,
+     1293, 1293, 1293, 1293, 1293, 1293, 1288, 1293, 1293, 1293,
+     1293, 1293, 1293, 1293, 1293, 1288, 1293, 1293, 1293, 1293,
+     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1295,
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295,
+     1295, 1295, 1295, 1295, 1295, 1295, 1295, 1295, 1288, 1292,
+
+     1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1315, 1316, 1293, 1288, 1293, 1293, 1293, 1288, 1293, 1293,
+     1293, 1293, 1288, 1293, 1293, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1294, 1295, 1295, 1295, 1295, 1295,
+     1295, 1295, 1295, 1295, 1295, 1288, 1292, 1292, 1292, 1292,
+     1292, 1292, 1292, 1292, 1292, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1317, 1318, 1293, 1288, 1293, 1293, 1293, 1288, 1293, 1293,
+     1293, 1288, 1293, 1293, 1294, 1294, 1294, 1294, 1294, 1294,
+     1294, 1294, 1294, 1295, 1295, 1295, 1295, 1295, 1295, 1295,
+     1295, 1295, 1319, 1292, 1292, 1292, 1292, 1292, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1320, 1321, 1288, 1293, 1293, 1293,
+     1288, 1293, 1293, 1288, 1293, 1293, 1322, 1294, 1294, 1294,
+     1294, 1294, 1294, 1294, 1323, 1295, 1295, 1295, 1295, 1295,
+     1295, 1295, 1319, 1288, 1292, 1292, 1288, 1288, 1288, 1288,
+
+     1288, 1288, 1288, 1288, 1288, 1324, 1325, 1293, 1288, 1293,
+     1293, 1288, 1293, 1322, 1294, 1294, 1294, 1294, 1294, 1323,
+     1295, 1295, 1295, 1295, 1292, 1292, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1326, 1288, 1288, 1293, 1288, 1293, 1294,
+     1294, 1295, 1295, 1292, 1292, 1292, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1327, 1288, 1293, 1288, 1293, 1294, 1294,
+     1295, 1295, 1292, 1292, 1292, 1292, 1292, 1288, 1288, 1288,
+     1288, 1288, 1288, 1328, 1288, 1288, 1288, 1288, 1288, 1329,
+     1288, 1288, 1330, 1331, 1332, 1333, 1288,    0, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288
+    } ;
+
+static yyconst flex_int16_t yy_nxt[1733] =
+    {   0,
+       12,   13,   14,   15,   16,   17,   18,   19,   20,   21,
+       12,   22,   23,   24,   25,   26,   27,   28,   28,   28,
+       28,   28,   28,   28,   28,   29,   30,   31,   32,   33,
+       34,   35,   35,   35,   35,   35,   35,   35,   35,   35,
+       35,   36,   35,   35,   37,   38,   35,   39,   40,   41,
+       42,   43,   44,   35,   35,   45,   35,   46,   47,   48,
+       49,   50,   35,   51,   52,   53,   35,   54,   35,   55,
+       35,   35,   56,   57,   58,   60,  105,  143,  106,   61,
+      107,  108,  144, 1059,  109,  311,  110,  171,  111,  159,
+      172,  112,  113,  312,  160,  114,  115,  115,  115,  115,
+
+      115,  115,  115,  115,  115,  161,  182, 1060,  183,  448,
+      145,  184,  147,  147,  147,  147,  147,  147,  147,  147,
+      147,   62,   63,   64,   65,   66,   67,  223,  449,   68,
+      224,   69,   70,   71,   72,   73,  151,   74,   75,   76,
+      155,   77,  156,   78,   60,  707,  162,  371,   61,  178,
+      185,  157,  186,  179,  708,  372,  163,  158,  164,  165,
+      173,  207,  180,  208,  174,  187,  166,  188,  175,  197,
+     1061,  189,  209,  176,  190,  191,  230,  192,  210,  177,
+      231,  198,  193,  211,  194,  195,  196,  199,  212,  232,
+       62,   63,   64,   65,   66,   67,  418,  418,   68,  213,
+
+       69,   70,   71,   72,   73,  283,   74,   75,   76,  284,
+       77,  214,   78,   80,   81,  200,  276,  349,  285,  277,
+      350,  215,   82,  216,  217,  225,  201,  351,  202,  226,
+      249,  218,  203,  227,  234,  237,  235,  238,  228,  236,
+      252,  260,  250,  261,  229,  444,  659,  470,  251,  264,
+      239,  253,  262,  254,  265,  471,  302,  255,  263,   83,
+       84,   85,   86,   87,   88,  266,  660,   89,  303,   90,
+       91,   92,   93,   94,  304,   95,   96,   97,  440,   98,
+      240,   99,   80,   81,  241,  428,  462,  242,  243,  429,
+      244,   82,  267,  463,  290,  245,  291,  246,  247,  248,
+
+      514,  591,  268,  278,  269,  270,  305,  279,  287,  292,
+      288,  280,  271,  289,  398,  441,  281,  306,  399,  307,
+      359,  502,  282,  308, 1062,  503,  360,  400,   83,   84,
+       85,   86,   87,   88,  361,  362,   89,  515,   90,   91,
+       92,   93,   94,  363,   95,   96,   97,  378,   98,  293,
+       99,   12,  364,  294,  317,  411,  295,  296,  487,  297,
+      488,  100,  412,  379,  298,  380,  299,  300,  301,  318,
+      319,  205,  413,  320,  478,  115,  115,  115,  115,  115,
+      115,  115,  115,  115,  401,  472,  402, 1063, 1064,  403,
+      404,  473,  489,   35,   35,   35,   35,   35,   35,  151,
+
+      490,   35,  545,   35,   35,   35,   35,   35,  546,   35,
+       35,   35, 1065,   35,  328,   35,  329,  521,  101,  116,
+      117,  118,  119,  330,  341,  331,  405,  332,  586,  342,
+      343,  456,  535,  457,  366,  458,  522,  344,  543,  536,
+      593,  345,  346,  367,  347, 1066,  544,  368,  369,  370,
+      120,  121,  122,  123,  124,  125,  126,  127,  128,  594,
+      129,  130,  131,  132,  133,  587,  134,  135,  136,  137,
+      138,  139,  140,  141,  142,  145, 1067,  146,  146,  146,
+      146,  146,  146,  146,  147,  147,  333,  559,  334,  560,
+      430,  335,  336,  148,  431,  149,  150, 1068,  561,  432,
+
+      352,  151,  353,  152,  373,  354,  562,  465,  374,  148,
+      480,  149,  433,  150,  574,  466,  337,  338,  575,  481,
+     1069,  375,  467,  376,  482,  483,  381,  406,  407,  408,
+      152, 1070,  339,  382,  383,  355,  384,  205,  356,  340,
+      444, 1071,  492,  615,  564,  493,  385,  565,  357,  358,
+      386,  616,  387,  633,  504,  388,  389,  494,  505,  566,
+      409,  634, 1072,  506,  410,  416,  416,  416,  416,  416,
+      416,  416,  416,  416,  538,  529,  507,  530, 1073,  531,
+      390,  631,  539,  632,  391,  392,  601,  393,  602,  540,
+      603,  617,  657,  607,  658,  781,  394,  618,  395,  396,
+
+      608,  519,  145,  397,  146,  146,  146,  146,  146,  146,
+      146,  147,  147,  145,  782,  147,  147,  147,  147,  147,
+      147,  147,  147,  147,  666,  670,  704,  610,  417,  667,
+      705,  636,  671, 1017,  637,  611,  686, 1018,  687,  151,
+      444,  444,  612,  444,  444,  444,  638,  444,  444,  444,
+      444,  444,  444,  444,  444,  444,  651,  651,  651,  651,
+      756,  205,  552, 1074,  743,  444,  444,  444,  444,  444,
+      444,  553,  624,  677,  576,  699,  554,  555,  577,  678,
+      739,  625,  746,  578,  444,  444,  626,  627,  700,  679,
+      716,  776,  740,  418,  418,  786,  579,  717,  790,  838,
+
+     1075,  787,  747,  757,  777,  805,  446, 1076,  824,  853,
+      791,  839,  444,  444,  444,  478,  478,  734,  478,  478,
+      478,  825,  478,  478,  478,  478,  478,  478,  478,  478,
+      478,  416,  416,  416,  416,  416,  416,  416,  416,  416,
+      478,  478,  478,  478,  478,  478,  796,  834,  806,  829,
+      844,  872,  854,  835,  877,  882, 1077, 1078, 1024,  478,
+      478,  883, 1005, 1079,  873, 1006,  797, 1080,  830, 1081,
+      845, 1082, 1025,  878, 1026, 1083, 1084, 1085, 1086, 1087,
+     1088, 1089, 1090, 1091, 1094, 1095, 1096,  478,  478,  478,
+      743,  743, 1092,  743,  743,  743, 1097,  743,  743,  743,
+
+      743,  743,  743,  743,  743,  743, 1098, 1099, 1100, 1093,
+     1101, 1102, 1103, 1104, 1105,  743,  743,  743,  743,  743,
+      743, 1106, 1107, 1108, 1109, 1110, 1113, 1114, 1115, 1116,
+     1117, 1118, 1119, 1120,  743,  743, 1121, 1122, 1123, 1124,
+     1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134,
+     1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144,
+     1146, 1147,  743,  743,  743, 1145, 1145, 1145, 1145, 1145,
+     1145, 1145, 1145, 1145, 1148, 1149, 1150, 1151, 1152, 1153,
+     1153, 1153, 1153, 1153, 1153, 1153, 1153, 1153, 1154, 1155,
+     1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1167,
+
+     1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177,
+     1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187,
+     1188, 1189, 1190, 1191, 1192, 1194, 1145, 1145, 1145, 1145,
+     1145, 1145, 1145, 1145, 1145, 1195, 1196, 1197, 1198, 1199,
+     1200, 1153, 1153, 1153, 1153, 1153, 1153, 1153, 1153, 1153,
+     1202, 1203, 1204, 1205, 1208, 1209, 1210, 1211, 1212, 1213,
+     1215, 1216, 1217, 1193, 1218, 1219, 1194, 1221, 1222, 1223,
+     1201, 1224, 1194, 1225, 1193, 1226, 1227, 1228, 1229, 1230,
+     1231, 1232, 1233, 1236, 1237, 1238, 1239, 1215, 1240, 1241,
+     1193, 1194, 1242, 1243, 1244, 1247, 1245, 1248, 1249, 1193,
+
+     1246, 1250, 1251, 1252, 1253, 1255, 1256, 1257, 1258, 1259,
+     1260, 1261, 1262, 1263, 1264, 1266, 1268, 1269, 1270, 1271,
+     1272, 1273, 1275, 1276, 1277, 1278, 1279, 1281, 1265, 1267,
+     1282,   59,   59,   59,   59,   59,   59,   79,   79,   79,
+       79,   79,   79,  103,  419,  103,  103,  103,  103,  104,
+      420,  104,  153,  421,  153,  205,  205,  735,  205,  205,
+      205,  257,  736,  257,  257,  937,  257,  415,  938,  415,
+      415,  415,  415,  445, 1041,  445,  445,  445,  445,  479,
+     1042,  479,  479,  479,  479,  518,  518,  518,  518,  518,
+      518,  551,  551,  551,  551,  551,  551,  590, 1111,  590,
+
+      590,  590,  590,  623, 1112,  623,  623,  623,  623,  744,
+     1165,  744,  744,  744,  744,  794,  794,  794,  794,  794,
+      794,  842, 1166,  842,  842,  842,  842, 1193, 1193, 1193,
+     1193, 1193, 1193, 1206, 1207, 1214, 1214, 1214, 1214, 1214,
+     1214, 1220, 1220, 1220, 1220, 1220, 1220, 1234, 1235, 1254,
+     1274, 1280, 1283, 1284, 1285, 1286, 1287, 1058, 1057, 1056,
+     1055, 1054, 1053, 1052, 1051, 1050, 1049, 1048, 1047, 1046,
+     1045, 1044, 1043, 1040, 1039, 1038, 1037, 1036, 1035, 1034,
+     1033, 1032, 1031, 1030, 1029, 1028, 1027, 1023, 1022, 1021,
+     1020, 1019, 1016, 1015, 1014, 1013, 1012, 1011, 1010, 1009,
+
+     1008, 1007, 1004, 1003, 1002, 1001, 1000,  999,  998,  997,
+      996,  995,  994,  993,  992,  991,  990,  989,  988,  987,
+      986,  985,  984,  983,  982,  981,  980,  979,  978,  977,
+      976,  975,  974,  973,  972,  971,  970,  969,  968,  967,
+      966,  965,  964,  963,  962,  961,  960,  959,  958,  957,
+      956,  955,  954,  953,  952,  951,  950,  949,  948,  947,
+      946,  945,  944,  943,  942,  941,  940,  939,  936,  935,
+      934,  933,  932,  931,  930,  929,  928,  927,  926,  925,
+      924,  923,  922,  921,  920,  919,  918,  917,  916,  915,
+      914,  913,  912,  911,  910,  909,  908,  907,  906,  905,
+
+      904,  903,  902,  901,  900,  899,  898,  897,  896,  895,
+      894,  893,  892,  891,  890,  889,  888,  887,  886,  885,
+      884,  881,  880,  879,  876,  875,  874,  871,  870,  869,
+      868,  867,  866,  865,  864,  863,  862,  861,  860,  859,
+      858,  857,  856,  855,  852,  852,  851,  850,  849,  848,
+      847,  846,  843,  743,  841,  840,  837,  836,  833,  832,
+      831,  828,  827,  826,  823,  822,  821,  820,  819,  818,
+      817,  816,  815,  814,  813,  812,  811,  810,  809,  808,
+      807,  804,  804,  803,  802,  801,  800,  799,  798,  795,
+      793,  792,  789,  788,  785,  784,  783,  780,  779,  778,
+
+      775,  774,  773,  772,  771,  770,  769,  768,  767,  766,
+      765,  764,  763,  762,  761,  760,  759,  758,  755,  755,
+      754,  753,  752,  751,  750,  749,  748,  745,  742,  741,
+      738,  737,  733,  732,  731,  730,  729,  728,  727,  726,
+      725,  724,  723,  722,  721,  720,  719,  718,  715,  714,
+      713,  712,  711,  710,  709,  706,  703,  702,  701,  698,
+      697,  696,  695,  694,  693,  692,  691,  690,  689,  688,
+      685,  684,  683,  682,  681,  680,  676,  675,  674,  673,
+      672,  669,  668,  665,  664,  663,  662,  661,  656,  655,
+      654,  653,  652,  650,  649,  648,  647,  646,  645,  644,
+
+      643,  642,  641,  640,  639,  635,  630,  629,  628,  478,
+      622,  621,  620,  619,  614,  613,  609,  606,  605,  604,
+      600,  599,  598,  597,  596,  595,  592,  589,  588,  585,
+      584,  583,  582,  581,  580,  573,  572,  571,  570,  569,
+      568,  567,  563,  558,  557,  556,  550,  549,  548,  547,
+      542,  541,  537,  534,  533,  532,  528,  527,  526,  525,
+      524,  523,  520,  517,  516,  513,  512,  511,  510,  509,
+      508,  501,  500,  499,  498,  497,  496,  495,  491,  486,
+      485,  484,  477,  476,  475,  474,  469,  468,  464,  461,
+      460,  459,  455,  454,  453,  452,  451,  450,  447,  443,
+
+      442,  439,  438,  437,  436,  435,  434,  427,  426,  425,
+      424,  423,  422,  414,  377,  365,  348,  327,  326,  325,
+      324,  323,  322,  321,  316,  315,  314,  313,  310,  144,
+      309,  286,  275,  274,  273,  272,  259,  258,  256,  233,
+      222,  221,  220,  219,  206,  204,  181,  170,  169,  168,
+      167,  154,  102, 1288,   56,   56,   11, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288
+    } ;
+
+static yyconst flex_int16_t yy_chk[1733] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    3,   19,   26,   19,    3,
+       19,   19,   26,  967,   19,  105,   19,   46,   19,   40,
+       46,   19,   19,  105,   40,   19,   24,   24,   24,   24,
+
+       24,   24,   24,   24,   24,   40,   50,  968,   50,  173,
+       28,   50,   28,   28,   28,   28,   28,   28,   28,   28,
+       28,    3,    3,    3,    3,    3,    3,   69,  173,    3,
+       69,    3,    3,    3,    3,    3,   28,    3,    3,    3,
+       39,    3,   39,    3,    4,  381,   41,  130,    4,   48,
+       51,   39,   51,   48,  381,  130,   41,   39,   41,   41,
+       47,   62,   48,   62,   47,   51,   41,   52,   47,   53,
+      970,   52,   62,   47,   52,   52,   71,   52,   62,   47,
+       71,   53,   52,   63,   52,   52,   52,   53,   63,   71,
+        4,    4,    4,    4,    4,    4,  148,  148,    4,   63,
+
+        4,    4,    4,    4,    4,   92,    4,    4,    4,   92,
+        4,   64,    4,    5,    5,   54,   90,  124,   92,   90,
+      124,   64,    5,   64,   64,   70,   54,  124,   54,   70,
+       76,   64,   54,   70,   73,   74,   73,   74,   70,   73,
+       77,   83,   76,   83,   70,  276,  331,  189,   76,   84,
+       74,   77,   83,   77,   84,  189,   97,   77,   83,    5,
+        5,    5,    5,    5,    5,   84,  331,    5,   97,    5,
+        5,    5,    5,    5,   97,    5,    5,    5,  168,    5,
+       75,    5,    6,    6,   75,  160,  184,   75,   75,  160,
+       75,    6,   85,  184,   95,   75,   95,   75,   75,   75,
+
+      220,  276,   85,   91,   85,   85,   98,   91,   94,   95,
+       94,   91,   85,   94,  136,  168,   91,   98,  136,   98,
+      126,  212,   91,   98,  973,  212,  126,  136,    6,    6,
+        6,    6,    6,    6,  126,  127,    6,  220,    6,    6,
+        6,    6,    6,  127,    6,    6,    6,  133,    6,   96,
+        6,    7,  127,   96,  110,  139,   96,   96,  200,   96,
+      200,    7,  139,  133,   96,  133,   96,   96,   96,  110,
+      110,  247,  139,  110,  247,  115,  115,  115,  115,  115,
+      115,  115,  115,  115,  137,  190,  137,  974,  976,  137,
+      137,  190,  201,    7,    7,    7,    7,    7,    7,  115,
+
+      201,    7,  242,    7,    7,    7,    7,    7,  242,    7,
+        7,    7,  979,    7,  120,    7,  120,  225,    7,   25,
+       25,   25,   25,  120,  122,  120,  137,  120,  273,  122,
+      122,  180,  236,  180,  129,  180,  225,  122,  241,  236,
+      278,  122,  122,  129,  122,  980,  241,  129,  129,  129,
+       25,   25,   25,   25,   25,   25,   25,   25,   25,  278,
+       25,   25,   25,   25,   25,  273,   25,   25,   25,   25,
+       25,   25,   25,   25,   25,   27,  981,   27,   27,   27,
+       27,   27,   27,   27,   27,   27,  121,  252,  121,  252,
+      161,  121,  121,   27,  161,   27,   27,  983,  253,  161,
+
+      125,   27,  125,   27,  131,  125,  253,  186,  131,   27,
+      196,   27,  161,   27,  265,  186,  121,  121,  265,  196,
+      986,  131,  186,  131,  196,  196,  134,  138,  138,  138,
+       27,  987,  121,  134,  134,  125,  134,  223,  125,  121,
+      223,  989,  203,  294,  255,  203,  134,  255,  125,  125,
+      135,  294,  135,  306,  213,  135,  135,  203,  213,  255,
+      138,  306,  992,  213,  138,  145,  145,  145,  145,  145,
+      145,  145,  145,  145,  238,  232,  213,  232,  993,  232,
+      135,  305,  238,  305,  135,  135,  285,  135,  285,  238,
+      285,  295,  330,  289,  330,  489,  135,  295,  135,  135,
+
+      289,  223,  146,  135,  146,  146,  146,  146,  146,  146,
+      146,  146,  146,  147,  489,  147,  147,  147,  147,  147,
+      147,  147,  147,  147,  338,  341,  379,  291,  146,  338,
+      379,  308,  341,  906,  308,  291,  358,  906,  358,  147,
+      171,  171,  291,  171,  171,  171,  308,  171,  171,  171,
+      171,  171,  171,  171,  171,  171,  321,  321,  321,  321,
+      448,  501,  248,  995,  501,  171,  171,  171,  171,  171,
+      171,  248,  301,  351,  266,  374,  248,  248,  266,  351,
+      424,  301,  431,  266,  171,  171,  301,  301,  374,  351,
+      390,  483,  424,  418,  418,  493,  266,  390,  498,  570,
+
+      998,  493,  431,  448,  483,  521,  171,  999,  555,  593,
+      498,  570,  171,  171,  171,  195,  195,  418,  195,  195,
+      195,  555,  195,  195,  195,  195,  195,  195,  195,  195,
+      195,  416,  416,  416,  416,  416,  416,  416,  416,  416,
+      195,  195,  195,  195,  195,  195,  505,  565,  521,  561,
+      577,  627,  593,  565,  633,  637, 1000, 1002,  919,  195,
+      195,  637,  891, 1003,  627,  891,  505, 1004,  561, 1005,
+      577, 1006,  919,  633,  919, 1007, 1009, 1010, 1011, 1013,
+     1014, 1016, 1017, 1018, 1021, 1022, 1024,  195,  195,  195,
+      427,  427, 1019,  427,  427,  427, 1025,  427,  427,  427,
+
+      427,  427,  427,  427,  427,  427, 1026, 1027, 1029, 1019,
+     1030, 1031, 1032, 1033, 1034,  427,  427,  427,  427,  427,
+      427, 1035, 1036, 1037, 1039, 1040, 1043, 1044, 1045, 1046,
+     1047, 1048, 1049, 1051,  427,  427, 1052, 1053, 1054, 1055,
+     1056, 1057, 1058, 1059, 1060, 1062, 1063, 1064, 1065, 1066,
+     1067, 1068, 1069, 1070, 1072, 1073, 1074, 1075, 1076, 1077,
+     1080, 1082,  427,  427,  427, 1078, 1078, 1078, 1078, 1078,
+     1078, 1078, 1078, 1078, 1084, 1086, 1089, 1090, 1091, 1092,
+     1092, 1092, 1092, 1092, 1092, 1092, 1092, 1092, 1093, 1096,
+     1097, 1098, 1099, 1101, 1102, 1103, 1106, 1109, 1110, 1114,
+
+     1115, 1116, 1117, 1118, 1119, 1121, 1122, 1123, 1124, 1125,
+     1126, 1127, 1128, 1129, 1131, 1132, 1133, 1134, 1135, 1136,
+     1137, 1138, 1140, 1141, 1142, 1143, 1145, 1145, 1145, 1145,
+     1145, 1145, 1145, 1145, 1145, 1146, 1147, 1149, 1150, 1151,
+     1152, 1153, 1153, 1153, 1153, 1153, 1153, 1153, 1153, 1153,
+     1154, 1155, 1158, 1160, 1169, 1171, 1172, 1173, 1174, 1175,
+     1177, 1179, 1181, 1177, 1182, 1183, 1185, 1187, 1189, 1190,
+     1153, 1191, 1193, 1195, 1185, 1196, 1197, 1198, 1199, 1200,
+     1203, 1204, 1205, 1209, 1210, 1212, 1213, 1214, 1217, 1219,
+     1214, 1220, 1222, 1224, 1226, 1227, 1226, 1228, 1229, 1220,
+
+     1226, 1230, 1231, 1232, 1233, 1236, 1237, 1238, 1239, 1240,
+     1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250,
+     1251, 1252, 1268, 1269, 1270, 1272, 1273, 1276, 1245, 1246,
+     1277, 1289, 1289, 1289, 1289, 1289, 1289, 1290, 1290, 1290,
+     1290, 1290, 1290, 1291, 1297, 1291, 1291, 1291, 1291, 1292,
+     1298, 1292, 1293, 1299, 1293, 1294, 1294, 1306, 1294, 1294,
+     1294, 1295, 1307, 1295, 1295, 1311, 1295, 1296, 1312, 1296,
+     1296, 1296, 1296, 1300, 1313, 1300, 1300, 1300, 1300, 1301,
+     1314, 1301, 1301, 1301, 1301, 1302, 1302, 1302, 1302, 1302,
+     1302, 1303, 1303, 1303, 1303, 1303, 1303, 1304, 1315, 1304,
+
+     1304, 1304, 1304, 1305, 1316, 1305, 1305, 1305, 1305, 1308,
+     1317, 1308, 1308, 1308, 1308, 1309, 1309, 1309, 1309, 1309,
+     1309, 1310, 1318, 1310, 1310, 1310, 1310, 1319, 1319, 1319,
+     1319, 1319, 1319, 1320, 1321, 1322, 1322, 1322, 1322, 1322,
+     1322, 1323, 1323, 1323, 1323, 1323, 1323, 1324, 1325, 1326,
+     1327, 1328, 1329, 1330, 1331, 1332, 1333,  964,  962,  961,
+      960,  957,  956,  954,  953,  950,  948,  947,  946,  943,
+      941,  940,  939,  935,  934,  933,  932,  931,  930,  929,
+      927,  926,  925,  924,  922,  921,  920,  918,  916,  911,
+      908,  907,  904,  902,  901,  900,  899,  898,  897,  895,
+
+      893,  892,  890,  889,  888,  887,  886,  885,  875,  873,
+      872,  869,  864,  861,  859,  857,  856,  855,  853,  852,
+      851,  847,  846,  844,  843,  842,  837,  827,  825,  824,
+      821,  816,  813,  811,  809,  808,  807,  805,  804,  803,
+      799,  798,  796,  795,  794,  789,  779,  777,  776,  773,
+      772,  767,  764,  762,  760,  759,  758,  756,  755,  754,
+      753,  749,  748,  746,  745,  744,  743,  738,  732,  731,
+      730,  729,  725,  724,  722,  721,  720,  719,  718,  716,
+      708,  705,  704,  703,  697,  696,  694,  691,  689,  687,
+      686,  684,  683,  679,  678,  677,  675,  672,  670,  669,
+
+      668,  667,  666,  665,  661,  657,  656,  654,  652,  650,
+      649,  648,  647,  646,  645,  644,  643,  642,  641,  640,
+      638,  636,  635,  634,  632,  631,  629,  625,  624,  623,
+      621,  620,  616,  615,  613,  612,  608,  607,  606,  605,
+      602,  599,  598,  595,  591,  590,  589,  587,  584,  582,
+      580,  578,  575,  573,  572,  571,  568,  566,  564,  563,
+      562,  560,  559,  557,  553,  552,  551,  549,  548,  544,
+      543,  541,  540,  536,  535,  534,  533,  530,  527,  526,
+      523,  519,  518,  517,  515,  512,  510,  508,  506,  503,
+      500,  499,  496,  494,  492,  491,  490,  488,  487,  485,
+
+      481,  480,  479,  478,  476,  475,  471,  470,  468,  467,
+      463,  462,  461,  460,  457,  454,  453,  450,  446,  445,
+      444,  443,  441,  438,  436,  434,  432,  429,  426,  425,
+      422,  421,  414,  412,  410,  409,  405,  403,  402,  401,
+      399,  398,  397,  396,  395,  394,  393,  391,  388,  387,
+      386,  385,  384,  383,  382,  380,  378,  376,  375,  373,
+      372,  371,  369,  367,  366,  365,  362,  361,  360,  359,
+      357,  356,  355,  354,  353,  352,  350,  349,  348,  346,
+      344,  340,  339,  337,  335,  334,  333,  332,  329,  328,
+      324,  323,  322,  320,  319,  318,  317,  316,  315,  314,
+
+      313,  312,  311,  310,  309,  307,  304,  303,  302,  300,
+      299,  298,  297,  296,  293,  292,  290,  288,  287,  286,
+      284,  283,  282,  281,  280,  279,  277,  275,  274,  272,
+      271,  270,  269,  268,  267,  264,  263,  262,  261,  260,
+      258,  256,  254,  251,  250,  249,  246,  245,  244,  243,
+      240,  239,  237,  235,  234,  233,  231,  230,  229,  228,
+      227,  226,  224,  222,  221,  219,  218,  217,  216,  215,
+      214,  211,  210,  209,  208,  207,  206,  204,  202,  199,
+      198,  197,  194,  193,  192,  191,  188,  187,  185,  183,
+      182,  181,  179,  178,  177,  176,  175,  174,  172,  170,
+
+      169,  167,  166,  165,  164,  163,  162,  159,  158,  157,
+      156,  155,  154,  140,  132,  128,  123,  119,  118,  117,
+      114,  113,  112,  111,  109,  108,  107,  106,  102,  100,
+       99,   93,   89,   88,   87,   86,   82,   80,   78,   72,
+       68,   67,   66,   65,   60,   55,   49,   45,   44,   43,
+       42,   36,   13,   11,   10,    9, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288, 1288,
+     1288, 1288
+    } ;
+
+/* Table of booleans, true if rule could match eol. */
+static yyconst flex_int32_t yy_rule_can_match_eol[290] =
+    {   0,
+0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 
+    0, 0, 0, 1, 0, 0, 1, 1, 0, 0,     };
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int ptx__flex_debug;
+int ptx__flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *ptx_text;
+#line 1 "ptx.l"
+/*
+Copyright (c) 2009-2011, Tor M. Aamodt
+The University of British Columbia
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+Redistributions of source code must retain the above copyright notice, this
+list of conditions and the following disclaimer.
+Redistributions in binary form must reproduce the above copyright notice, this
+list of conditions and the following disclaimer in the documentation and/or
+other materials provided with the distribution.
+Neither the name of The University of British Columbia nor the names of its
+contributors may be used to endorse or promote products derived from this
+software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#line 35 "ptx.l"
+#include "opcodes.h"
+#include "ptx.tab.h"
+#include <string.h>
+
+char linebuf[1024];
+unsigned col = 0;
+#define TC col+=strlen(ptx_text); 
+#define CHECK_UNSIGNED \
+	if( ptx_text[strlen(ptx_text)-1]=='U' ) { \
+		printf("GPGPU-Sim: ERROR ** U modifier not implemented\n"); \
+		abort(); \
+	}
+int ptx_error( const char *s );
+
+
+
+
+#line 1378 "lex.ptx_.c"
+
+#define INITIAL 0
+#define IN_STRING 1
+#define IN_COMMENT 2
+#define IN_FUNC_DECL 3
+#define NOT_OPCODE 4
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int ptx_lex_destroy (void );
+
+int ptx_get_debug (void );
+
+void ptx_set_debug (int debug_flag  );
+
+YY_EXTRA_TYPE ptx_get_extra (void );
+
+void ptx_set_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *ptx_get_in (void );
+
+void ptx_set_in  (FILE * in_str  );
+
+FILE *ptx_get_out (void );
+
+void ptx_set_out  (FILE * out_str  );
+
+int ptx_get_leng (void );
+
+char *ptx_get_text (void );
+
+int ptx_get_lineno (void );
+
+void ptx_set_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int ptx_wrap (void );
+#else
+extern int ptx_wrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( ptx_text, ptx_leng, 1, ptx_out )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( ptx_in )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( ptx_in ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, ptx_in))==0 && ferror(ptx_in)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(ptx_in); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int ptx_lex (void);
+
+#define YY_DECL int ptx_lex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after ptx_text and ptx_leng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 54 "ptx.l"
+
+
+#line 1570 "lex.ptx_.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! ptx_in )
+			ptx_in = stdin;
+
+		if ( ! ptx_out )
+			ptx_out = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			ptx_ensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				ptx__create_buffer(ptx_in,YY_BUF_SIZE );
+		}
+
+		ptx__load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of ptx_text. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 1289 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 1657 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
+			{
+			int yyl;
+			for ( yyl = 0; yyl < ptx_leng; ++yyl )
+				if ( ptx_text[yyl] == '\n' )
+					   
+    ptx_lineno++;
+;
+			}
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 56 "ptx.l"
+TC; ptx_lval.int_value = ABS_OP; return OPCODE;
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 57 "ptx.l"
+TC; ptx_lval.int_value = ADD_OP; return OPCODE;
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 58 "ptx.l"
+TC; ptx_lval.int_value = ADDP_OP; return OPCODE;
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 59 "ptx.l"
+TC; ptx_lval.int_value = ADDC_OP; return OPCODE;
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 60 "ptx.l"
+TC; ptx_lval.int_value = AND_OP; return OPCODE;
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 61 "ptx.l"
+TC; ptx_lval.int_value = ANDN_OP; return OPCODE;
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 62 "ptx.l"
+TC; ptx_lval.int_value = ATOM_OP; return OPCODE;
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 63 "ptx.l"
+TC; ptx_lval.int_value = BAR_OP; return OPCODE;
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 64 "ptx.l"
+TC; ptx_lval.int_value = BFE_OP; return OPCODE;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 65 "ptx.l"
+TC; ptx_lval.int_value = BFI_OP; return OPCODE;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 66 "ptx.l"
+TC; ptx_lval.int_value = BFIND_OP; return OPCODE;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 67 "ptx.l"
+TC; ptx_lval.int_value = BRA_OP; return OPCODE;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 68 "ptx.l"
+TC; ptx_lval.int_value = BRX_OP; return OPCODE;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 69 "ptx.l"
+TC; ptx_lval.int_value = BREV_OP; return OPCODE;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 70 "ptx.l"
+TC; ptx_lval.int_value = BRKPT_OP; return OPCODE;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 71 "ptx.l"
+TC; BEGIN(NOT_OPCODE); ptx_lval.int_value = CALL_OP; return OPCODE; // blocking opcode token in case the callee has the same name as an opcode
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 72 "ptx.l"
+TC; BEGIN(NOT_OPCODE); ptx_lval.int_value = CALLP_OP; return OPCODE;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 73 "ptx.l"
+TC; ptx_lval.int_value = CLZ_OP; return OPCODE;
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 74 "ptx.l"
+TC; ptx_lval.int_value = CNOT_OP; return OPCODE;
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 75 "ptx.l"
+TC; ptx_lval.int_value = COS_OP; return OPCODE;
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 76 "ptx.l"
+TC; ptx_lval.int_value = CVT_OP; return OPCODE;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 77 "ptx.l"
+TC; ptx_lval.int_value = CVTA_OP; return OPCODE;
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 78 "ptx.l"
+TC; ptx_lval.int_value = DIV_OP; return OPCODE;
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 79 "ptx.l"
+TC; ptx_lval.int_value = EX2_OP; return OPCODE;
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 80 "ptx.l"
+TC; ptx_lval.int_value = EXIT_OP; return OPCODE;
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 81 "ptx.l"
+TC; ptx_lval.int_value = FMA_OP; return OPCODE;
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 82 "ptx.l"
+TC; ptx_lval.int_value = ISSPACEP_OP; return OPCODE;
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 83 "ptx.l"
+TC; ptx_lval.int_value = LD_OP; return OPCODE;
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 84 "ptx.l"
+TC; ptx_lval.int_value = LD_OP; return OPCODE;
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 85 "ptx.l"
+TC; ptx_lval.int_value = LDU_OP; return OPCODE;
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 86 "ptx.l"
+TC; ptx_lval.int_value = LG2_OP; return OPCODE;
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 87 "ptx.l"
+TC; ptx_lval.int_value = MAD24_OP; return OPCODE;
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 88 "ptx.l"
+TC; ptx_lval.int_value = MAD_OP; return OPCODE;
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 89 "ptx.l"
+TC; ptx_lval.int_value = MADP_OP; return OPCODE;
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 90 "ptx.l"
+TC; ptx_lval.int_value = MAX_OP; return OPCODE;
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 91 "ptx.l"
+TC; ptx_lval.int_value = MEMBAR_OP; return OPCODE;
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 92 "ptx.l"
+TC; ptx_lval.int_value = MIN_OP; return OPCODE;
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 93 "ptx.l"
+TC; ptx_lval.int_value = MOV_OP; return OPCODE;
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 94 "ptx.l"
+TC; ptx_lval.int_value = MUL24_OP; return OPCODE;
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 95 "ptx.l"
+TC; ptx_lval.int_value = MUL_OP; return OPCODE;
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 96 "ptx.l"
+TC; ptx_lval.int_value = NEG_OP; return OPCODE;
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 97 "ptx.l"
+TC; ptx_lval.int_value = NANDN_OP; return OPCODE;
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+#line 98 "ptx.l"
+TC; ptx_lval.int_value = NORN_OP; return OPCODE;
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+#line 99 "ptx.l"
+TC; ptx_lval.int_value = NOT_OP; return OPCODE;
+	YY_BREAK
+case 45:
+YY_RULE_SETUP
+#line 100 "ptx.l"
+TC; ptx_lval.int_value = OR_OP; return OPCODE;
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+#line 101 "ptx.l"
+TC; ptx_lval.int_value = ORN_OP; return OPCODE;
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+#line 102 "ptx.l"
+TC; ptx_lval.int_value = PMEVENT_OP; return OPCODE;
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 103 "ptx.l"
+TC; ptx_lval.int_value = POPC_OP; return OPCODE;
+	YY_BREAK
+case 49:
+YY_RULE_SETUP
+#line 104 "ptx.l"
+TC; ptx_lval.int_value = PREFETCH_OP; return OPCODE;
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
+#line 105 "ptx.l"
+TC; ptx_lval.int_value = PREFETCHU_OP; return OPCODE;
+	YY_BREAK
+case 51:
+YY_RULE_SETUP
+#line 106 "ptx.l"
+TC; ptx_lval.int_value = PRMT_OP; return OPCODE;
+	YY_BREAK
+case 52:
+YY_RULE_SETUP
+#line 107 "ptx.l"
+TC; ptx_lval.int_value = RCP_OP; return OPCODE;
+	YY_BREAK
+case 53:
+YY_RULE_SETUP
+#line 108 "ptx.l"
+TC; ptx_lval.int_value = RED_OP; return OPCODE;
+	YY_BREAK
+case 54:
+YY_RULE_SETUP
+#line 109 "ptx.l"
+TC; ptx_lval.int_value = REM_OP; return OPCODE;
+	YY_BREAK
+case 55:
+YY_RULE_SETUP
+#line 110 "ptx.l"
+TC; ptx_lval.int_value = RET_OP; return OPCODE;
+	YY_BREAK
+case 56:
+YY_RULE_SETUP
+#line 111 "ptx.l"
+TC; ptx_lval.int_value = RETP_OP; return OPCODE;
+	YY_BREAK
+case 57:
+YY_RULE_SETUP
+#line 112 "ptx.l"
+TC; ptx_lval.int_value = RSQRT_OP; return OPCODE;
+	YY_BREAK
+case 58:
+YY_RULE_SETUP
+#line 113 "ptx.l"
+TC; ptx_lval.int_value = SAD_OP; return OPCODE;
+	YY_BREAK
+case 59:
+YY_RULE_SETUP
+#line 114 "ptx.l"
+TC; ptx_lval.int_value = SELP_OP; return OPCODE;
+	YY_BREAK
+case 60:
+YY_RULE_SETUP
+#line 115 "ptx.l"
+TC; ptx_lval.int_value = SETP_OP; return OPCODE;
+	YY_BREAK
+case 61:
+YY_RULE_SETUP
+#line 116 "ptx.l"
+TC; ptx_lval.int_value = SET_OP; return OPCODE;
+	YY_BREAK
+case 62:
+YY_RULE_SETUP
+#line 117 "ptx.l"
+TC; ptx_lval.int_value = SHL_OP; return OPCODE;
+	YY_BREAK
+case 63:
+YY_RULE_SETUP
+#line 118 "ptx.l"
+TC; ptx_lval.int_value = SHR_OP; return OPCODE;
+	YY_BREAK
+case 64:
+YY_RULE_SETUP
+#line 119 "ptx.l"
+TC; ptx_lval.int_value = SIN_OP; return OPCODE;
+	YY_BREAK
+case 65:
+YY_RULE_SETUP
+#line 120 "ptx.l"
+TC; ptx_lval.int_value = SLCT_OP; return OPCODE;
+	YY_BREAK
+case 66:
+YY_RULE_SETUP
+#line 121 "ptx.l"
+TC; ptx_lval.int_value = SQRT_OP; return OPCODE;
+	YY_BREAK
+case 67:
+YY_RULE_SETUP
+#line 122 "ptx.l"
+TC; ptx_lval.int_value = SSY_OP; return OPCODE;
+	YY_BREAK
+case 68:
+YY_RULE_SETUP
+#line 123 "ptx.l"
+TC; ptx_lval.int_value = ST_OP; return OPCODE;
+	YY_BREAK
+case 69:
+YY_RULE_SETUP
+#line 124 "ptx.l"
+TC; ptx_lval.int_value = ST_OP; return OPCODE;
+	YY_BREAK
+case 70:
+YY_RULE_SETUP
+#line 125 "ptx.l"
+TC; ptx_lval.int_value = SUB_OP; return OPCODE;
+	YY_BREAK
+case 71:
+YY_RULE_SETUP
+#line 126 "ptx.l"
+TC; ptx_lval.int_value = SUBC_OP; return OPCODE;
+	YY_BREAK
+case 72:
+YY_RULE_SETUP
+#line 127 "ptx.l"
+TC; ptx_lval.int_value = SULD_OP; return OPCODE;
+	YY_BREAK
+case 73:
+YY_RULE_SETUP
+#line 128 "ptx.l"
+TC; ptx_lval.int_value = SURED_OP; return OPCODE;
+	YY_BREAK
+case 74:
+YY_RULE_SETUP
+#line 129 "ptx.l"
+TC; ptx_lval.int_value = SUST_OP; return OPCODE;
+	YY_BREAK
+case 75:
+YY_RULE_SETUP
+#line 130 "ptx.l"
+TC; ptx_lval.int_value = SUQ_OP; return OPCODE;
+	YY_BREAK
+case 76:
+YY_RULE_SETUP
+#line 131 "ptx.l"
+TC; BEGIN(NOT_OPCODE); ptx_lval.int_value = TEX_OP; return OPCODE;
+	YY_BREAK
+case 77:
+YY_RULE_SETUP
+#line 132 "ptx.l"
+TC; ptx_lval.int_value = TEX_OP; return OPCODE;
+	YY_BREAK
+case 78:
+YY_RULE_SETUP
+#line 133 "ptx.l"
+TC; ptx_lval.int_value = TRAP_OP; return OPCODE;
+	YY_BREAK
+case 79:
+YY_RULE_SETUP
+#line 134 "ptx.l"
+TC; ptx_lval.int_value = VABSDIFF_OP; return OPCODE;
+	YY_BREAK
+case 80:
+YY_RULE_SETUP
+#line 135 "ptx.l"
+TC; ptx_lval.int_value = VADD_OP; return OPCODE;
+	YY_BREAK
+case 81:
+YY_RULE_SETUP
+#line 136 "ptx.l"
+TC; ptx_lval.int_value = VMAD_OP; return OPCODE;
+	YY_BREAK
+case 82:
+YY_RULE_SETUP
+#line 137 "ptx.l"
+TC; ptx_lval.int_value = VMAX_OP; return OPCODE;
+	YY_BREAK
+case 83:
+YY_RULE_SETUP
+#line 138 "ptx.l"
+TC; ptx_lval.int_value = VMIN_OP; return OPCODE;
+	YY_BREAK
+case 84:
+YY_RULE_SETUP
+#line 139 "ptx.l"
+TC; ptx_lval.int_value = VSET_OP; return OPCODE;
+	YY_BREAK
+case 85:
+YY_RULE_SETUP
+#line 140 "ptx.l"
+TC; ptx_lval.int_value = VSHL_OP; return OPCODE;
+	YY_BREAK
+case 86:
+YY_RULE_SETUP
+#line 141 "ptx.l"
+TC; ptx_lval.int_value = VSHR_OP; return OPCODE;
+	YY_BREAK
+case 87:
+YY_RULE_SETUP
+#line 142 "ptx.l"
+TC; ptx_lval.int_value = VSUB_OP; return OPCODE;
+	YY_BREAK
+case 88:
+YY_RULE_SETUP
+#line 143 "ptx.l"
+TC; ptx_lval.int_value = VOTE_OP; return OPCODE;
+	YY_BREAK
+case 89:
+YY_RULE_SETUP
+#line 144 "ptx.l"
+TC; ptx_lval.int_value = XOR_OP; return OPCODE;
+	YY_BREAK
+case 90:
+YY_RULE_SETUP
+#line 145 "ptx.l"
+TC; ptx_lval.int_value = NOP_OP; return OPCODE;
+	YY_BREAK
+case 91:
+YY_RULE_SETUP
+#line 146 "ptx.l"
+TC; ptx_lval.int_value = BREAK_OP; return OPCODE;
+	YY_BREAK
+case 92:
+YY_RULE_SETUP
+#line 147 "ptx.l"
+TC; ptx_lval.int_value = BREAKADDR_OP; return OPCODE;
+	YY_BREAK
+
+case 93:
+YY_RULE_SETUP
+#line 151 "ptx.l"
+TC; return ALIGN_DIRECTIVE;
+	YY_BREAK
+case 94:
+YY_RULE_SETUP
+#line 152 "ptx.l"
+TC; return BRANCHTARGETS_DIRECTIVE;
+	YY_BREAK
+case 95:
+YY_RULE_SETUP
+#line 153 "ptx.l"
+TC; return BYTE_DIRECTIVE; /* not in PTX 2.1 */
+	YY_BREAK
+case 96:
+YY_RULE_SETUP
+#line 154 "ptx.l"
+TC; return CALLPROTOTYPE_DIRECTIVE;
+	YY_BREAK
+case 97:
+YY_RULE_SETUP
+#line 155 "ptx.l"
+TC; return CALLTARGETS_DIRECTIVE;
+	YY_BREAK
+case 98:
+YY_RULE_SETUP
+#line 156 "ptx.l"
+TC; ptx_lval.int_value = atoi(ptx_text+7); return CONST_DIRECTIVE;
+	YY_BREAK
+case 99:
+YY_RULE_SETUP
+#line 157 "ptx.l"
+TC; ptx_lval.int_value = 0; return CONST_DIRECTIVE;
+	YY_BREAK
+case 100:
+YY_RULE_SETUP
+#line 158 "ptx.l"
+TC; return ENTRY_DIRECTIVE;
+	YY_BREAK
+case 101:
+YY_RULE_SETUP
+#line 159 "ptx.l"
+TC; return EXTERN_DIRECTIVE;
+	YY_BREAK
+case 102:
+YY_RULE_SETUP
+#line 160 "ptx.l"
+TC; BEGIN(INITIAL); return FILE_DIRECTIVE;
+	YY_BREAK
+case 103:
+YY_RULE_SETUP
+#line 161 "ptx.l"
+TC; BEGIN(IN_FUNC_DECL); return FUNC_DIRECTIVE; // blocking opcode parsing in case the function has the same name as an opcode (e.g. sin(), cos())
+	YY_BREAK
+case 104:
+YY_RULE_SETUP
+#line 162 "ptx.l"
+TC; return GLOBAL_DIRECTIVE;
+	YY_BREAK
+case 105:
+YY_RULE_SETUP
+#line 163 "ptx.l"
+TC; return LOCAL_DIRECTIVE;
+	YY_BREAK
+case 106:
+YY_RULE_SETUP
+#line 164 "ptx.l"
+TC; return LOC_DIRECTIVE;
+	YY_BREAK
+case 107:
+YY_RULE_SETUP
+#line 165 "ptx.l"
+TC; return MAXNCTAPERSM_DIRECTIVE;
+	YY_BREAK
+case 108:
+YY_RULE_SETUP
+#line 166 "ptx.l"
+TC; return MAXNNREG_DIRECTIVE;
+	YY_BREAK
+case 109:
+YY_RULE_SETUP
+#line 167 "ptx.l"
+TC; return MAXNTID_DIRECTIVE;
+	YY_BREAK
+case 110:
+YY_RULE_SETUP
+#line 168 "ptx.l"
+TC; return MINNCTAPERSM_DIRECTIVE;
+	YY_BREAK
+case 111:
+YY_RULE_SETUP
+#line 169 "ptx.l"
+TC; return PARAM_DIRECTIVE;
+	YY_BREAK
+case 112:
+YY_RULE_SETUP
+#line 170 "ptx.l"
+TC; return PRAGMA_DIRECTIVE;
+	YY_BREAK
+case 113:
+YY_RULE_SETUP
+#line 171 "ptx.l"
+TC; return REG_DIRECTIVE;
+	YY_BREAK
+case 114:
+YY_RULE_SETUP
+#line 172 "ptx.l"
+TC; return REQNTID_DIRECTIVE;
+	YY_BREAK
+case 115:
+YY_RULE_SETUP
+#line 173 "ptx.l"
+TC; return SECTION_DIRECTIVE;
+	YY_BREAK
+case 116:
+YY_RULE_SETUP
+#line 174 "ptx.l"
+TC; return SHARED_DIRECTIVE;
+	YY_BREAK
+case 117:
+YY_RULE_SETUP
+#line 175 "ptx.l"
+TC; return SREG_DIRECTIVE;
+	YY_BREAK
+case 118:
+YY_RULE_SETUP
+#line 176 "ptx.l"
+TC; return STRUCT_DIRECTIVE;
+	YY_BREAK
+case 119:
+YY_RULE_SETUP
+#line 177 "ptx.l"
+TC; return SURF_DIRECTIVE;   /* not in PTX 2.1 */
+	YY_BREAK
+case 120:
+YY_RULE_SETUP
+#line 178 "ptx.l"
+TC; return TARGET_DIRECTIVE;
+	YY_BREAK
+case 121:
+YY_RULE_SETUP
+#line 179 "ptx.l"
+TC; BEGIN(NOT_OPCODE); return TEX_DIRECTIVE;
+	YY_BREAK
+case 122:
+YY_RULE_SETUP
+#line 180 "ptx.l"
+TC; return UNION_DIRECTIVE; /* not in PTX 2.1 */
+	YY_BREAK
+case 123:
+YY_RULE_SETUP
+#line 181 "ptx.l"
+TC; return VERSION_DIRECTIVE;
+	YY_BREAK
+case 124:
+YY_RULE_SETUP
+#line 182 "ptx.l"
+TC; return VISIBLE_DIRECTIVE;
+	YY_BREAK
+case 125:
+YY_RULE_SETUP
+#line 183 "ptx.l"
+TC; return ADDRESS_SIZE_DIRECTIVE;
+	YY_BREAK
+case 126:
+YY_RULE_SETUP
+#line 185 "ptx.l"
+TC; return CONSTPTR_DIRECTIVE; /* Ptx plus directive for pointer to constant memory */
+	YY_BREAK
+case 127:
+YY_RULE_SETUP
+#line 186 "ptx.l"
+TC; return PTR_DIRECTIVE; /* Added for new OpenCL genrated code */
+	YY_BREAK
+case 128:
+YY_RULE_SETUP
+#line 188 "ptx.l"
+TC; ptx_lval.int_value = CLOCK_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 129:
+YY_RULE_SETUP
+#line 189 "ptx.l"
+TC; ptx_lval.int_value = HALFCLOCK_ID; return SPECIAL_REGISTER;
+	YY_BREAK
+case 130:
+YY_RULE_SETUP
+#line 190 "ptx.l"
+TC; ptx_lval.int_value = CLOCK64_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 131:
+YY_RULE_SETUP
+#line 191 "ptx.l"
+TC; ptx_lval.int_value = CTAID_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 132:
+YY_RULE_SETUP
+#line 192 "ptx.l"
+TC; sscanf(ptx_text+7,"%u",&ptx_lval.int_value); ptx_lval.int_value<<=16; ptx_lval.int_value += ENVREG_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 133:
+YY_RULE_SETUP
+#line 193 "ptx.l"
+TC; ptx_lval.int_value = GRIDID_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 134:
+YY_RULE_SETUP
+#line 194 "ptx.l"
+TC; ptx_lval.int_value = LANEID_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 135:
+YY_RULE_SETUP
+#line 195 "ptx.l"
+TC; ptx_lval.int_value = LANEMASK_EQ_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 136:
+YY_RULE_SETUP
+#line 196 "ptx.l"
+TC; ptx_lval.int_value = LANEMASK_LE_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 137:
+YY_RULE_SETUP
+#line 197 "ptx.l"
+TC; ptx_lval.int_value = LANEMASK_LT_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 138:
+YY_RULE_SETUP
+#line 198 "ptx.l"
+TC; ptx_lval.int_value = LANEMASK_GE_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 139:
+YY_RULE_SETUP
+#line 199 "ptx.l"
+TC; ptx_lval.int_value = LANEMASK_GT_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 140:
+YY_RULE_SETUP
+#line 200 "ptx.l"
+TC; ptx_lval.int_value = NCTAID_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 141:
+YY_RULE_SETUP
+#line 201 "ptx.l"
+TC; ptx_lval.int_value = NTID_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 142:
+YY_RULE_SETUP
+#line 202 "ptx.l"
+TC; ptx_lval.int_value = NSMID_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 143:
+YY_RULE_SETUP
+#line 203 "ptx.l"
+TC; ptx_lval.int_value = NWARPID_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 144:
+YY_RULE_SETUP
+#line 204 "ptx.l"
+TC; sscanf(ptx_text+3,"%u",&ptx_lval.int_value); ptx_lval.int_value<<=16; ptx_lval.int_value += PM_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 145:
+YY_RULE_SETUP
+#line 205 "ptx.l"
+TC; ptx_lval.int_value = SMID_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 146:
+YY_RULE_SETUP
+#line 206 "ptx.l"
+TC; ptx_lval.int_value = TID_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 147:
+YY_RULE_SETUP
+#line 207 "ptx.l"
+TC; ptx_lval.int_value = WARPID_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 148:
+YY_RULE_SETUP
+#line 208 "ptx.l"
+TC; ptx_lval.int_value = WARPSZ_REG; return SPECIAL_REGISTER;
+	YY_BREAK
+case 149:
+YY_RULE_SETUP
+#line 210 "ptx.l"
+TC; ptx_lval.string_value = strdup(ptx_text); return IDENTIFIER;
+	YY_BREAK
+case 150:
+YY_RULE_SETUP
+#line 211 "ptx.l"
+TC; ptx_lval.string_value = strdup(ptx_text); return IDENTIFIER;
+	YY_BREAK
+case 151:
+YY_RULE_SETUP
+#line 213 "ptx.l"
+TC; sscanf(ptx_text,"%lf", &ptx_lval.double_value); return DOUBLE_OPERAND;
+	YY_BREAK
+case 152:
+YY_RULE_SETUP
+#line 215 "ptx.l"
+TC; CHECK_UNSIGNED; sscanf(ptx_text,"%x", &ptx_lval.int_value); return INT_OPERAND;
+	YY_BREAK
+case 153:
+YY_RULE_SETUP
+#line 216 "ptx.l"
+TC; printf("GPGPU-Sim: ERROR ** parsing octal not (yet) implemented\n"); abort(); return INT_OPERAND;
+	YY_BREAK
+case 154:
+YY_RULE_SETUP
+#line 217 "ptx.l"
+TC; printf("GPGPU-Sim: ERROR ** parsing binary not (yet) implemented\n"); abort(); return INT_OPERAND;
+	YY_BREAK
+case 155:
+YY_RULE_SETUP
+#line 218 "ptx.l"
+TC; CHECK_UNSIGNED; ptx_lval.int_value =  atoi(ptx_text); return INT_OPERAND;
+	YY_BREAK
+case 156:
+YY_RULE_SETUP
+#line 220 "ptx.l"
+TC; sscanf(ptx_text+2,"%x", (unsigned*)(void*)&ptx_lval.float_value); return FLOAT_OPERAND;
+	YY_BREAK
+case 157:
+YY_RULE_SETUP
+#line 221 "ptx.l"
+TC; sscanf(ptx_text+2,"%Lx", (unsigned long long*)(void*)&ptx_lval.double_value); return DOUBLE_OPERAND;
+	YY_BREAK
+case 158:
+YY_RULE_SETUP
+#line 223 "ptx.l"
+TC;  return S8_TYPE;
+	YY_BREAK
+case 159:
+YY_RULE_SETUP
+#line 224 "ptx.l"
+TC;  return S16_TYPE;
+	YY_BREAK
+case 160:
+YY_RULE_SETUP
+#line 225 "ptx.l"
+TC;  return S32_TYPE;
+	YY_BREAK
+case 161:
+YY_RULE_SETUP
+#line 226 "ptx.l"
+TC;  return S64_TYPE;
+	YY_BREAK
+case 162:
+YY_RULE_SETUP
+#line 227 "ptx.l"
+TC;  return U8_TYPE;
+	YY_BREAK
+case 163:
+YY_RULE_SETUP
+#line 228 "ptx.l"
+TC;  return U16_TYPE;
+	YY_BREAK
+case 164:
+YY_RULE_SETUP
+#line 229 "ptx.l"
+TC;  return U32_TYPE;
+	YY_BREAK
+case 165:
+YY_RULE_SETUP
+#line 230 "ptx.l"
+TC;  return U64_TYPE;
+	YY_BREAK
+case 166:
+YY_RULE_SETUP
+#line 231 "ptx.l"
+TC;  return F16_TYPE;
+	YY_BREAK
+case 167:
+YY_RULE_SETUP
+#line 232 "ptx.l"
+TC;  return F32_TYPE;
+	YY_BREAK
+case 168:
+YY_RULE_SETUP
+#line 233 "ptx.l"
+TC;  return F64_TYPE;
+	YY_BREAK
+case 169:
+YY_RULE_SETUP
+#line 234 "ptx.l"
+TC;  return FF64_TYPE;
+	YY_BREAK
+case 170:
+YY_RULE_SETUP
+#line 235 "ptx.l"
+TC;  return B8_TYPE;
+	YY_BREAK
+case 171:
+YY_RULE_SETUP
+#line 236 "ptx.l"
+TC;  return B16_TYPE;
+	YY_BREAK
+case 172:
+YY_RULE_SETUP
+#line 237 "ptx.l"
+TC;  return B32_TYPE;
+	YY_BREAK
+case 173:
+YY_RULE_SETUP
+#line 238 "ptx.l"
+TC;  return B64_TYPE;
+	YY_BREAK
+case 174:
+YY_RULE_SETUP
+#line 239 "ptx.l"
+TC;  return BB64_TYPE;
+	YY_BREAK
+case 175:
+YY_RULE_SETUP
+#line 240 "ptx.l"
+TC;  return BB128_TYPE;
+	YY_BREAK
+case 176:
+YY_RULE_SETUP
+#line 241 "ptx.l"
+TC;  return PRED_TYPE;
+	YY_BREAK
+case 177:
+YY_RULE_SETUP
+#line 243 "ptx.l"
+TC; BEGIN(NOT_OPCODE); return TEXREF_TYPE;
+	YY_BREAK
+case 178:
+YY_RULE_SETUP
+#line 244 "ptx.l"
+TC;  return SAMPLERREF_TYPE;
+	YY_BREAK
+case 179:
+YY_RULE_SETUP
+#line 245 "ptx.l"
+TC;  return SURFREF_TYPE;
+	YY_BREAK
+case 180:
+YY_RULE_SETUP
+#line 247 "ptx.l"
+TC; return V2_TYPE;
+	YY_BREAK
+case 181:
+YY_RULE_SETUP
+#line 248 "ptx.l"
+TC; return V3_TYPE;
+	YY_BREAK
+case 182:
+YY_RULE_SETUP
+#line 249 "ptx.l"
+TC; return V4_TYPE;
+	YY_BREAK
+case 183:
+YY_RULE_SETUP
+#line 251 "ptx.l"
+TC; return HALF_OPTION; /* ptxplus */
+	YY_BREAK
+case 184:
+YY_RULE_SETUP
+#line 253 "ptx.l"
+TC; return EQU_OPTION;
+	YY_BREAK
+case 185:
+YY_RULE_SETUP
+#line 254 "ptx.l"
+TC; return NEU_OPTION;
+	YY_BREAK
+case 186:
+YY_RULE_SETUP
+#line 255 "ptx.l"
+TC; return LTU_OPTION;
+	YY_BREAK
+case 187:
+YY_RULE_SETUP
+#line 256 "ptx.l"
+TC; return LEU_OPTION;
+	YY_BREAK
+case 188:
+YY_RULE_SETUP
+#line 257 "ptx.l"
+TC; return GTU_OPTION;
+	YY_BREAK
+case 189:
+YY_RULE_SETUP
+#line 258 "ptx.l"
+TC; return GEU_OPTION;
+	YY_BREAK
+case 190:
+YY_RULE_SETUP
+#line 259 "ptx.l"
+TC; return NUM_OPTION;
+	YY_BREAK
+case 191:
+YY_RULE_SETUP
+#line 260 "ptx.l"
+TC; return NAN_OPTION;
+	YY_BREAK
+case 192:
+YY_RULE_SETUP
+#line 262 "ptx.l"
+TC; return SAT_OPTION;
+	YY_BREAK
+case 193:
+YY_RULE_SETUP
+#line 264 "ptx.l"
+TC; return EQ_OPTION;
+	YY_BREAK
+case 194:
+YY_RULE_SETUP
+#line 265 "ptx.l"
+TC; return NE_OPTION;
+	YY_BREAK
+case 195:
+YY_RULE_SETUP
+#line 266 "ptx.l"
+TC; return LT_OPTION;
+	YY_BREAK
+case 196:
+YY_RULE_SETUP
+#line 267 "ptx.l"
+TC; return LE_OPTION;
+	YY_BREAK
+case 197:
+YY_RULE_SETUP
+#line 268 "ptx.l"
+TC; return GT_OPTION;
+	YY_BREAK
+case 198:
+YY_RULE_SETUP
+#line 269 "ptx.l"
+TC; return GE_OPTION;
+	YY_BREAK
+case 199:
+YY_RULE_SETUP
+#line 270 "ptx.l"
+TC; return CF_OPTION;
+	YY_BREAK
+case 200:
+YY_RULE_SETUP
+#line 271 "ptx.l"
+TC; return SF_OPTION;
+	YY_BREAK
+case 201:
+YY_RULE_SETUP
+#line 272 "ptx.l"
+TC; return NSF_OPTION;
+	YY_BREAK
+case 202:
+YY_RULE_SETUP
+#line 274 "ptx.l"
+TC; return LO_OPTION;
+	YY_BREAK
+case 203:
+YY_RULE_SETUP
+#line 275 "ptx.l"
+TC; return LS_OPTION;
+	YY_BREAK
+case 204:
+YY_RULE_SETUP
+#line 276 "ptx.l"
+TC; return HI_OPTION;
+	YY_BREAK
+case 205:
+YY_RULE_SETUP
+#line 277 "ptx.l"
+TC; return HS_OPTION;
+	YY_BREAK
+case 206:
+YY_RULE_SETUP
+#line 280 "ptx.l"
+TC; return RNI_OPTION;
+	YY_BREAK
+case 207:
+YY_RULE_SETUP
+#line 281 "ptx.l"
+TC; return RZI_OPTION;
+	YY_BREAK
+case 208:
+YY_RULE_SETUP
+#line 282 "ptx.l"
+TC; return RMI_OPTION;
+	YY_BREAK
+case 209:
+YY_RULE_SETUP
+#line 283 "ptx.l"
+TC; return RPI_OPTION;
+	YY_BREAK
+case 210:
+YY_RULE_SETUP
+#line 285 "ptx.l"
+TC; return RN_OPTION;
+	YY_BREAK
+case 211:
+YY_RULE_SETUP
+#line 286 "ptx.l"
+TC; return RZ_OPTION;
+	YY_BREAK
+case 212:
+YY_RULE_SETUP
+#line 287 "ptx.l"
+TC; return RM_OPTION;
+	YY_BREAK
+case 213:
+YY_RULE_SETUP
+#line 288 "ptx.l"
+TC; return RP_OPTION;
+	YY_BREAK
+case 214:
+YY_RULE_SETUP
+#line 290 "ptx.l"
+TC; return FTZ_OPTION;
+	YY_BREAK
+case 215:
+YY_RULE_SETUP
+#line 292 "ptx.l"
+TC; return NEG_OPTION;
+	YY_BREAK
+case 216:
+YY_RULE_SETUP
+#line 294 "ptx.l"
+TC; return WIDE_OPTION;
+	YY_BREAK
+case 217:
+YY_RULE_SETUP
+#line 295 "ptx.l"
+TC; return UNI_OPTION;
+	YY_BREAK
+case 218:
+YY_RULE_SETUP
+#line 297 "ptx.l"
+TC; return APPROX_OPTION;
+	YY_BREAK
+case 219:
+YY_RULE_SETUP
+#line 298 "ptx.l"
+TC; return FULL_OPTION;
+	YY_BREAK
+case 220:
+YY_RULE_SETUP
+#line 300 "ptx.l"
+TC; return ANY_OPTION;
+	YY_BREAK
+case 221:
+YY_RULE_SETUP
+#line 301 "ptx.l"
+TC; return ALL_OPTION;
+	YY_BREAK
+case 222:
+YY_RULE_SETUP
+#line 302 "ptx.l"
+TC; return BALLOT_OPTION;
+	YY_BREAK
+case 223:
+YY_RULE_SETUP
+#line 303 "ptx.l"
+TC; return GLOBAL_OPTION;
+	YY_BREAK
+case 224:
+YY_RULE_SETUP
+#line 304 "ptx.l"
+TC; return CTA_OPTION;
+	YY_BREAK
+case 225:
+YY_RULE_SETUP
+#line 305 "ptx.l"
+TC; return SYS_OPTION;
+	YY_BREAK
+case 226:
+YY_RULE_SETUP
+#line 307 "ptx.l"
+TC; return EXIT_OPTION;
+	YY_BREAK
+case 227:
+YY_RULE_SETUP
+#line 309 "ptx.l"
+TC; return ABS_OPTION;
+	YY_BREAK
+case 228:
+YY_RULE_SETUP
+#line 311 "ptx.l"
+TC; return TO_OPTION;
+	YY_BREAK
+case 229:
+YY_RULE_SETUP
+#line 313 "ptx.l"
+TC; return CA_OPTION;
+	YY_BREAK
+case 230:
+YY_RULE_SETUP
+#line 314 "ptx.l"
+TC; return CG_OPTION;
+	YY_BREAK
+case 231:
+YY_RULE_SETUP
+#line 315 "ptx.l"
+TC; return CS_OPTION;
+	YY_BREAK
+case 232:
+YY_RULE_SETUP
+#line 316 "ptx.l"
+TC; return LU_OPTION;
+	YY_BREAK
+case 233:
+YY_RULE_SETUP
+#line 317 "ptx.l"
+TC; return CV_OPTION;
+	YY_BREAK
+case 234:
+YY_RULE_SETUP
+#line 319 "ptx.l"
+TC; return WB_OPTION;
+	YY_BREAK
+case 235:
+YY_RULE_SETUP
+#line 320 "ptx.l"
+TC; return WT_OPTION;
+	YY_BREAK
+case 236:
+YY_RULE_SETUP
+#line 322 "ptx.l"
+TC; return ATOMIC_AND;
+	YY_BREAK
+case 237:
+YY_RULE_SETUP
+#line 323 "ptx.l"
+TC; return ATOMIC_OR;
+	YY_BREAK
+case 238:
+YY_RULE_SETUP
+#line 324 "ptx.l"
+TC; return ATOMIC_XOR;
+	YY_BREAK
+case 239:
+YY_RULE_SETUP
+#line 325 "ptx.l"
+TC; return ATOMIC_CAS;
+	YY_BREAK
+case 240:
+YY_RULE_SETUP
+#line 326 "ptx.l"
+TC; return ATOMIC_EXCH;
+	YY_BREAK
+case 241:
+YY_RULE_SETUP
+#line 327 "ptx.l"
+TC; return ATOMIC_ADD;
+	YY_BREAK
+case 242:
+YY_RULE_SETUP
+#line 328 "ptx.l"
+TC; return ATOMIC_INC;
+	YY_BREAK
+case 243:
+YY_RULE_SETUP
+#line 329 "ptx.l"
+TC; return ATOMIC_DEC;
+	YY_BREAK
+case 244:
+YY_RULE_SETUP
+#line 330 "ptx.l"
+TC; return ATOMIC_MIN;
+	YY_BREAK
+case 245:
+YY_RULE_SETUP
+#line 331 "ptx.l"
+TC; return ATOMIC_MAX;
+	YY_BREAK
+case 246:
+YY_RULE_SETUP
+#line 333 "ptx.l"
+TC; return GEOM_MODIFIER_1D;
+	YY_BREAK
+case 247:
+YY_RULE_SETUP
+#line 334 "ptx.l"
+TC; return GEOM_MODIFIER_2D;
+	YY_BREAK
+case 248:
+YY_RULE_SETUP
+#line 335 "ptx.l"
+TC; return GEOM_MODIFIER_3D;
+	YY_BREAK
+case 249:
+YY_RULE_SETUP
+#line 337 "ptx.l"
+TC; ptx_lval.int_value = 0; return DIMENSION_MODIFIER;
+	YY_BREAK
+case 250:
+YY_RULE_SETUP
+#line 338 "ptx.l"
+TC; ptx_lval.int_value = 1; return DIMENSION_MODIFIER;
+	YY_BREAK
+case 251:
+YY_RULE_SETUP
+#line 339 "ptx.l"
+TC; ptx_lval.int_value = 2; return DIMENSION_MODIFIER;
+	YY_BREAK
+case 252:
+YY_RULE_SETUP
+#line 340 "ptx.l"
+TC; ptx_lval.int_value = 0; return DIMENSION_MODIFIER;
+	YY_BREAK
+case 253:
+YY_RULE_SETUP
+#line 341 "ptx.l"
+TC; ptx_lval.int_value = 1; return DIMENSION_MODIFIER;
+	YY_BREAK
+case 254:
+YY_RULE_SETUP
+#line 342 "ptx.l"
+TC; ptx_lval.int_value = 2; return DIMENSION_MODIFIER;
+	YY_BREAK
+case 255:
+YY_RULE_SETUP
+#line 344 "ptx.l"
+TC; return MINUS;
+	YY_BREAK
+case 256:
+YY_RULE_SETUP
+#line 345 "ptx.l"
+TC; return PLUS;
+	YY_BREAK
+case 257:
+YY_RULE_SETUP
+#line 346 "ptx.l"
+TC; return COMMA;
+	YY_BREAK
+case 258:
+YY_RULE_SETUP
+#line 347 "ptx.l"
+TC; return PRED;
+	YY_BREAK
+case 259:
+YY_RULE_SETUP
+#line 348 "ptx.l"
+TC; return PIPE;
+	YY_BREAK
+case 260:
+YY_RULE_SETUP
+#line 349 "ptx.l"
+TC; return LEFT_SQUARE_BRACKET;
+	YY_BREAK
+case 261:
+YY_RULE_SETUP
+#line 350 "ptx.l"
+TC; return RIGHT_SQUARE_BRACKET;
+	YY_BREAK
+case 262:
+YY_RULE_SETUP
+#line 351 "ptx.l"
+TC; return LEFT_ANGLE_BRACKET;
+	YY_BREAK
+case 263:
+YY_RULE_SETUP
+#line 352 "ptx.l"
+TC; return RIGHT_ANGLE_BRACKET;
+	YY_BREAK
+case 264:
+YY_RULE_SETUP
+#line 353 "ptx.l"
+TC; return LEFT_PAREN;
+	YY_BREAK
+case 265:
+YY_RULE_SETUP
+#line 354 "ptx.l"
+TC; return RIGHT_PAREN;
+	YY_BREAK
+case 266:
+YY_RULE_SETUP
+#line 355 "ptx.l"
+TC; BEGIN(INITIAL); return COLON;
+	YY_BREAK
+case 267:
+YY_RULE_SETUP
+#line 356 "ptx.l"
+TC; BEGIN(INITIAL); return SEMI_COLON;
+	YY_BREAK
+case 268:
+YY_RULE_SETUP
+#line 357 "ptx.l"
+TC; return EXCLAMATION;
+	YY_BREAK
+case 269:
+YY_RULE_SETUP
+#line 358 "ptx.l"
+TC; return EQUALS;
+	YY_BREAK
+case 270:
+YY_RULE_SETUP
+#line 359 "ptx.l"
+TC; return RIGHT_BRACE;
+	YY_BREAK
+case 271:
+YY_RULE_SETUP
+#line 360 "ptx.l"
+TC; return PERIOD;
+	YY_BREAK
+case 272:
+YY_RULE_SETUP
+#line 361 "ptx.l"
+TC; return BACKSLASH;
+	YY_BREAK
+case 273:
+YY_RULE_SETUP
+#line 363 "ptx.l"
+TC;	// eat single
+	YY_BREAK
+case 274:
+/* rule 274 can match eol */
+YY_RULE_SETUP
+#line 365 "ptx.l"
+col=0; strncpy(linebuf, ptx_text + 1, 1024); yyless( 1 );
+	YY_BREAK
+case 275:
+YY_RULE_SETUP
+#line 367 "ptx.l"
+TC;
+	YY_BREAK
+case 276:
+YY_RULE_SETUP
+#line 368 "ptx.l"
+TC;
+	YY_BREAK
+
+case 277:
+YY_RULE_SETUP
+#line 373 "ptx.l"
+TC; BEGIN(INITIAL); return LEFT_BRACE; // starting a statement block (allow next token to be parsed as an opcode)
+	YY_BREAK
+case 278:
+YY_RULE_SETUP
+#line 374 "ptx.l"
+TC; return LEFT_BRACE; // starting a vector operand (next token cannot be opcode)
+	YY_BREAK
+
+case 279:
+YY_RULE_SETUP
+#line 377 "ptx.l"
+BEGIN(IN_COMMENT);
+	YY_BREAK
+
+
+case 280:
+YY_RULE_SETUP
+#line 380 "ptx.l"
+BEGIN(INITIAL);
+	YY_BREAK
+case 281:
+YY_RULE_SETUP
+#line 381 "ptx.l"
+// eat comment in chunks
+	YY_BREAK
+case 282:
+YY_RULE_SETUP
+#line 382 "ptx.l"
+// eat the lone star
+	YY_BREAK
+case 283:
+/* rule 283 can match eol */
+YY_RULE_SETUP
+#line 383 "ptx.l"
+TC; 
+	YY_BREAK
+
+
+case 284:
+YY_RULE_SETUP
+#line 387 "ptx.l"
+BEGIN(IN_STRING);
+	YY_BREAK
+
+
+case 285:
+YY_RULE_SETUP
+#line 390 "ptx.l"
+TC; BEGIN(INITIAL); return STRING;
+	YY_BREAK
+case 286:
+/* rule 286 can match eol */
+YY_RULE_SETUP
+#line 391 "ptx.l"
+TC; ptx_lval.string_value = strdup(ptx_text); 
+	YY_BREAK
+
+case 287:
+/* rule 287 can match eol */
+YY_RULE_SETUP
+#line 394 "ptx.l"
+
+	YY_BREAK
+case 288:
+YY_RULE_SETUP
+#line 396 "ptx.l"
+TC; ptx_error((const char*)NULL);
+	YY_BREAK
+case 289:
+YY_RULE_SETUP
+#line 397 "ptx.l"
+ECHO;
+	YY_BREAK
+#line 3122 "lex.ptx_.c"
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(IN_STRING):
+case YY_STATE_EOF(IN_COMMENT):
+case YY_STATE_EOF(IN_FUNC_DECL):
+case YY_STATE_EOF(NOT_OPCODE):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed ptx_in at a new source and called
+			 * ptx_lex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = ptx_in;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( ptx_wrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * ptx_text, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of ptx_lex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					ptx_realloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			ptx_restart(ptx_in  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) ptx_realloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 1289 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 1289 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 1288);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					ptx_restart(ptx_in );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( ptx_wrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve ptx_text */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	if ( c == '\n' )
+		   
+    ptx_lineno++;
+;
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void ptx_restart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        ptx_ensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            ptx__create_buffer(ptx_in,YY_BUF_SIZE );
+	}
+
+	ptx__init_buffer(YY_CURRENT_BUFFER,input_file );
+	ptx__load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void ptx__switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		ptx_pop_buffer_state();
+	 *		ptx_push_buffer_state(new_buffer);
+     */
+	ptx_ensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	ptx__load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (ptx_wrap()) processing, but the only time this flag
+	 * is looked at is after ptx_wrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void ptx__load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	ptx_in = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE ptx__create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) ptx_alloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in ptx__create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) ptx_alloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in ptx__create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	ptx__init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with ptx__create_buffer()
+ * 
+ */
+    void ptx__delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		ptx_free((void *) b->yy_ch_buf  );
+
+	ptx_free((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a ptx_restart() or at EOF.
+ */
+    static void ptx__init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	ptx__flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then ptx__init_buffer was _probably_
+     * called from ptx_restart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void ptx__flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		ptx__load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void ptx_push_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	ptx_ensure_buffer_stack();
+
+	/* This block is copied from ptx__switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from ptx__switch_to_buffer. */
+	ptx__load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void ptx_pop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	ptx__delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		ptx__load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void ptx_ensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)ptx_alloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in ptx_ensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)ptx_realloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in ptx_ensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE ptx__scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) ptx_alloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in ptx__scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	ptx__switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to ptx_lex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       ptx__scan_bytes() instead.
+ */
+YY_BUFFER_STATE ptx__scan_string (yyconst char * yystr )
+{
+    
+	return ptx__scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to ptx_lex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE ptx__scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) ptx_alloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in ptx__scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = ptx__scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in ptx__scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up ptx_text. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		ptx_text[ptx_leng] = (yy_hold_char); \
+		(yy_c_buf_p) = ptx_text + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		ptx_leng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int ptx_get_lineno  (void)
+{
+        
+    return ptx_lineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *ptx_get_in  (void)
+{
+        return ptx_in;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *ptx_get_out  (void)
+{
+        return ptx_out;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int ptx_get_leng  (void)
+{
+        return ptx_leng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *ptx_get_text  (void)
+{
+        return ptx_text;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void ptx_set_lineno (int  line_number )
+{
+    
+    ptx_lineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see ptx__switch_to_buffer
+ */
+void ptx_set_in (FILE *  in_str )
+{
+        ptx_in = in_str ;
+}
+
+void ptx_set_out (FILE *  out_str )
+{
+        ptx_out = out_str ;
+}
+
+int ptx_get_debug  (void)
+{
+        return ptx__flex_debug;
+}
+
+void ptx_set_debug (int  bdebug )
+{
+        ptx__flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from ptx_lex_destroy(), so don't allocate here.
+     */
+
+    /* We do not touch ptx_lineno unless the option is enabled. */
+    ptx_lineno =  1;
+    
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    ptx_in = stdin;
+    ptx_out = stdout;
+#else
+    ptx_in = (FILE *) 0;
+    ptx_out = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * ptx_lex_init()
+     */
+    return 0;
+}
+
+/* ptx_lex_destroy is for both reentrant and non-reentrant scanners. */
+int ptx_lex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		ptx__delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		ptx_pop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	ptx_free((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * ptx_lex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *ptx_alloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *ptx_realloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void ptx_free (void * ptr )
+{
+	free( (char *) ptr );	/* see ptx_realloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 397 "ptx.l"
+
+
+
+extern int g_error_detected;
+extern const char *g_filename;
+
+int ptx_error( const char *s )
+{
+	int i;
+	g_error_detected = 1;
+	fflush(stdout);
+	if( s != NULL )
+		printf("%s:%u: Syntax error:\n\n", g_filename, ptx_lineno );
+	printf("   %s\n", linebuf );
+	printf("   ");
+	for( i=0; i < col-1; i++ ) {
+		if( linebuf[i] == '\t' ) printf("\t");
+		else printf(" ");
+	}
+			
+	printf("^\n\n");
+	fflush(stdout);
+	//exit(1);
+	return 0;
+}
+
diff --git a/cuda-sim/lex.ptxinfo_.c b/cuda-sim/lex.ptxinfo_.c
new file mode 100644
--- /dev/null
+++ b/cuda-sim/lex.ptxinfo_.c
@@ -0,0 +1,2083 @@
+#line 2 "lex.ptxinfo_.c"
+
+#line 4 "lex.ptxinfo_.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer ptxinfo__create_buffer
+#define yy_delete_buffer ptxinfo__delete_buffer
+#define yy_flex_debug ptxinfo__flex_debug
+#define yy_init_buffer ptxinfo__init_buffer
+#define yy_flush_buffer ptxinfo__flush_buffer
+#define yy_load_buffer_state ptxinfo__load_buffer_state
+#define yy_switch_to_buffer ptxinfo__switch_to_buffer
+#define yyin ptxinfo_in
+#define yyleng ptxinfo_leng
+#define yylex ptxinfo_lex
+#define yylineno ptxinfo_lineno
+#define yyout ptxinfo_out
+#define yyrestart ptxinfo_restart
+#define yytext ptxinfo_text
+#define yywrap ptxinfo_wrap
+#define yyalloc ptxinfo_alloc
+#define yyrealloc ptxinfo_realloc
+#define yyfree ptxinfo_free
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE ptxinfo_restart(ptxinfo_in  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int ptxinfo_leng;
+
+extern FILE *ptxinfo_in, *ptxinfo_out;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
+     *       access to the local variable yy_act. Since yyless() is a macro, it would break
+     *       existing scanners that call yyless() from OUTSIDE ptxinfo_lex. 
+     *       One obvious solution it to make yy_act a global. I tried that, and saw
+     *       a 5% performance hit in a non-ptxinfo_lineno scanner, because yy_act is
+     *       normally declared as a register variable-- so it is not worth it.
+     */
+    #define  YY_LESS_LINENO(n) \
+            do { \
+                int yyl;\
+                for ( yyl = n; yyl < ptxinfo_leng; ++yyl )\
+                    if ( ptxinfo_text[yyl] == '\n' )\
+                        --ptxinfo_lineno;\
+            }while(0)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up ptxinfo_text. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up ptxinfo_text again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via ptxinfo_restart()), so that the user can continue scanning by
+	 * just pointing ptxinfo_in at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when ptxinfo_text is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int ptxinfo_leng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow ptxinfo_wrap()'s to do buffer switches
+ * instead of setting up a fresh ptxinfo_in.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void ptxinfo_restart (FILE *input_file  );
+void ptxinfo__switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE ptxinfo__create_buffer (FILE *file,int size  );
+void ptxinfo__delete_buffer (YY_BUFFER_STATE b  );
+void ptxinfo__flush_buffer (YY_BUFFER_STATE b  );
+void ptxinfo_push_buffer_state (YY_BUFFER_STATE new_buffer  );
+void ptxinfo_pop_buffer_state (void );
+
+static void ptxinfo_ensure_buffer_stack (void );
+static void ptxinfo__load_buffer_state (void );
+static void ptxinfo__init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER ptxinfo__flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE ptxinfo__scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE ptxinfo__scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE ptxinfo__scan_bytes (yyconst char *bytes,int len  );
+
+void *ptxinfo_alloc (yy_size_t  );
+void *ptxinfo_realloc (void *,yy_size_t  );
+void ptxinfo_free (void *  );
+
+#define yy_new_buffer ptxinfo__create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        ptxinfo_ensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ptxinfo__create_buffer(ptxinfo_in,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        ptxinfo_ensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ptxinfo__create_buffer(ptxinfo_in,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define ptxinfo_wrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *ptxinfo_in = (FILE *) 0, *ptxinfo_out = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int ptxinfo_lineno;
+
+int ptxinfo_lineno = 1;
+
+extern char *ptxinfo_text;
+#define yytext_ptr ptxinfo_text
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up ptxinfo_text.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	ptxinfo_leng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 26
+#define YY_END_OF_BUFFER 27
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[137] =
+    {   0,
+        0,    0,   27,   26,   24,   25,   23,   14,   22,   16,
+       17,   26,   15,   20,   21,   14,   14,   18,   19,   14,
+       14,   14,   14,   14,   14,   14,   14,   14,   25,   14,
+       15,   14,   14,   14,   14,   14,   14,   14,   14,   14,
+       14,   14,   14,   14,   14,   14,   14,   13,   14,   14,
+       14,   14,   14,   14,   14,   14,    6,   14,   11,    4,
+       12,    9,   14,   14,   10,   14,   14,    8,    3,   14,
+       14,   14,    0,   14,   14,   14,    0,   14,    2,   14,
+        0,   14,    2,    2,   14,    0,    7,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    5,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    1,    1,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    4,    1,    1,    1,    5,    6,    1,    7,    1,
+        1,    1,    8,    9,   10,    1,    1,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   12,   13,    1,
+        1,    1,    1,    1,    5,    5,   14,    5,    5,   15,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,   16,    5,    5,    5,    5,    5,
+       17,    1,   18,    1,    5,    1,   19,   20,   21,   22,
+
+       23,   24,   25,    5,   26,    5,    5,   27,   28,   29,
+       30,   31,    5,   32,   33,   34,   35,    5,   36,   37,
+       38,    5,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[39] =
+    {   0,
+        1,    1,    2,    1,    3,    1,    1,    1,    1,    1,
+        3,    1,    1,    3,    3,    3,    1,    1,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3
+    } ;
+
+static yyconst flex_int16_t yy_base[143] =
+    {   0,
+        0,    0,  179,  180,  180,    0,  180,    0,  180,  180,
+      180,  167,  166,  180,  180,  146,  142,  180,  180,  136,
+      145,  142,  142,   13,  136,  146,  140,  148,    0,    0,
+      155,  137,  141,  129,  139,  129,  136,  130,  135,  120,
+      131,  132,  122,  122,  130,  128,  122,    0,  119,  125,
+      119,  127,  119,  116,  114,  116,    0,  108,    0,    0,
+        0,    0,  107,  106,    0,  112,  110,    0,  132,  101,
+      105,  107,  106,  108,  105,  100,   99,   95,   41,  101,
+      101,   91,    0,   59,  119,   92,    0,   98,  116,   90,
+      114,   83,  112,   83,  110,   75,  100,  107,  106,   85,
+
+       93,   72,   71,   76,   75,   82,   81,   67,   66,   73,
+       72,   67,   66,   66,   65,  180,   89,   60,   53,   52,
+       48,   52,   42,   39,   44,   41,   29,   53,   32,   25,
+       20,   43,   41,    0,    0,  180,   77,   37,   80,   83,
+       86,   89
+    } ;
+
+static yyconst flex_int16_t yy_def[143] =
+    {   0,
+      136,    1,  136,  136,  136,  137,  136,  138,  136,  136,
+      136,  136,  136,  136,  136,  138,  138,  136,  136,  138,
+      138,  138,  138,  138,  138,  138,  138,  138,  137,  138,
+      136,  138,  138,  138,  138,  138,  138,  138,  138,  138,
+      138,  138,  138,  138,  138,  138,  138,  138,  138,  138,
+      138,  138,  138,  138,  138,  138,  138,  138,  138,  138,
+      138,  138,  138,  138,  138,  138,  138,  138,  138,  138,
+      138,  138,  136,  138,  138,  138,  136,  138,  139,  138,
+      136,  138,  140,  139,  138,  136,  138,  136,  136,  136,
+      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+
+      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+      136,  141,  141,  142,  142,    0,  136,  136,  136,  136,
+      136,  136
+    } ;
+
+static yyconst flex_int16_t yy_nxt[219] =
+    {   0,
+        4,    5,    6,    7,    8,    8,    9,   10,   11,   12,
+       13,   14,   15,   16,    8,   17,   18,   19,    8,   20,
+       21,    8,    8,   22,    8,   23,   24,    8,    8,    8,
+       25,   26,   27,    8,    8,   28,    8,    8,   38,   30,
+       39,   83,   83,  134,   83,  134,   83,   83,   83,   83,
+       83,  132,   83,   83,  131,  130,  129,   83,   83,   83,
+       83,  128,   83,  127,   83,   83,   83,   83,   83,  126,
+       83,   83,  125,  124,  123,   83,   83,   29,  122,   29,
+       84,  121,   84,   83,  120,   83,  133,  133,  133,  135,
+      119,  135,  118,  117,  116,  115,  114,  113,  112,  111,
+
+      110,  109,  108,  107,  106,  105,  104,  103,  102,  101,
+      100,   99,   98,   97,   96,   95,   94,   93,   92,   91,
+       90,   89,   88,   87,   86,   85,   82,   81,   80,   79,
+       78,   77,   76,   75,   74,   73,   72,   71,   70,   69,
+       68,   67,   66,   65,   64,   63,   62,   61,   60,   59,
+       58,   57,   56,   55,   54,   53,   52,   51,   50,   49,
+       48,   47,   46,   45,   44,   31,   43,   42,   41,   40,
+       37,   36,   35,   34,   33,   32,   31,   31,  136,    3,
+      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+
+      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+      136,  136,  136,  136,  136,  136,  136,  136
+    } ;
+
+static yyconst flex_int16_t yy_chk[219] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,   24,  138,
+       24,   79,   79,  133,   79,  132,   79,   79,   79,   79,
+       79,  131,   79,   79,  130,  129,  128,   79,   79,   84,
+       84,  127,   84,  126,   84,   84,   84,   84,   84,  125,
+       84,   84,  124,  123,  122,   84,   84,  137,  121,  137,
+      139,  120,  139,  140,  119,  140,  141,  141,  141,  142,
+      118,  142,  117,  115,  114,  113,  112,  111,  110,  109,
+
+      108,  107,  106,  105,  104,  103,  102,  101,  100,   99,
+       98,   97,   96,   95,   94,   93,   92,   91,   90,   89,
+       88,   86,   85,   82,   81,   80,   78,   77,   76,   75,
+       74,   73,   72,   71,   70,   69,   67,   66,   64,   63,
+       58,   56,   55,   54,   53,   52,   51,   50,   49,   47,
+       46,   45,   44,   43,   42,   41,   40,   39,   38,   37,
+       36,   35,   34,   33,   32,   31,   28,   27,   26,   25,
+       23,   22,   21,   20,   17,   16,   13,   12,    3,  136,
+      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+
+      136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
+      136,  136,  136,  136,  136,  136,  136,  136
+    } ;
+
+/* Table of booleans, true if rule could match eol. */
+static yyconst flex_int32_t yy_rule_can_match_eol[27] =
+    {   0,
+1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 1, 0,     };
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int ptxinfo__flex_debug;
+int ptxinfo__flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *ptxinfo_text;
+#line 1 "ptxinfo.l"
+/*
+Copyright (c) 2009-2011, Tor M. Aamodt
+The University of British Columbia
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+Redistributions of source code must retain the above copyright notice, this
+list of conditions and the following disclaimer.
+Redistributions in binary form must reproduce the above copyright notice, this
+list of conditions and the following disclaimer in the documentation and/or
+other materials provided with the distribution.
+Neither the name of The University of British Columbia nor the names of its
+contributors may be used to endorse or promote products derived from this
+software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#line 35 "ptxinfo.l"
+#include "ptxinfo.tab.h"
+#include <string.h>
+
+#define LINEBUF_SIZE 1024
+char ptxinfo_linebuf[LINEBUF_SIZE];
+unsigned ptxinfo_col = 0;
+#define TC if( (ptxinfo_lineno == 1) && ((ptxinfo_col + strlen(ptxinfo_text)) < LINEBUF_SIZE) ) { \
+		strncpy(ptxinfo_linebuf+ptxinfo_col,ptxinfo_text,strlen(ptxinfo_text)); \
+	   } \
+	   ptxinfo_col+=strlen(ptxinfo_text); 
+#line 632 "lex.ptxinfo_.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int ptxinfo_lex_destroy (void );
+
+int ptxinfo_get_debug (void );
+
+void ptxinfo_set_debug (int debug_flag  );
+
+YY_EXTRA_TYPE ptxinfo_get_extra (void );
+
+void ptxinfo_set_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *ptxinfo_get_in (void );
+
+void ptxinfo_set_in  (FILE * in_str  );
+
+FILE *ptxinfo_get_out (void );
+
+void ptxinfo_set_out  (FILE * out_str  );
+
+int ptxinfo_get_leng (void );
+
+char *ptxinfo_get_text (void );
+
+int ptxinfo_get_lineno (void );
+
+void ptxinfo_set_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int ptxinfo_wrap (void );
+#else
+extern int ptxinfo_wrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( ptxinfo_text, ptxinfo_leng, 1, ptxinfo_out )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( ptxinfo_in )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( ptxinfo_in ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, ptxinfo_in))==0 && ferror(ptxinfo_in)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(ptxinfo_in); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int ptxinfo_lex (void);
+
+#define YY_DECL int ptxinfo_lex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after ptxinfo_text and ptxinfo_leng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 47 "ptxinfo.l"
+
+#line 821 "lex.ptxinfo_.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! ptxinfo_in )
+			ptxinfo_in = stdin;
+
+		if ( ! ptxinfo_out )
+			ptxinfo_out = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			ptxinfo_ensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				ptxinfo__create_buffer(ptxinfo_in,YY_BUF_SIZE );
+		}
+
+		ptxinfo__load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of ptxinfo_text. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 137 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 180 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
+			{
+			int yyl;
+			for ( yyl = 0; yyl < ptxinfo_leng; ++yyl )
+				if ( ptxinfo_text[yyl] == '\n' )
+					   
+    ptxinfo_lineno++;
+;
+			}
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+/* rule 1 can match eol */
+YY_RULE_SETUP
+#line 48 "ptxinfo.l"
+
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 49 "ptxinfo.l"
+TC; return WARNING;
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 50 "ptxinfo.l"
+TC; 	return HEADER;
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 51 "ptxinfo.l"
+TC; 	return INFO;
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 52 "ptxinfo.l"
+TC; return FUNC;
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 53 "ptxinfo.l"
+TC; return USED;
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 54 "ptxinfo.l"
+TC; return REGS;
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 55 "ptxinfo.l"
+TC; return BYTES;
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 56 "ptxinfo.l"
+TC; return LMEM;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 57 "ptxinfo.l"
+TC; return SMEM;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 58 "ptxinfo.l"
+TC; return CMEM;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 59 "ptxinfo.l"
+TC; return LINE;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 60 "ptxinfo.l"
+TC; return FOR;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 62 "ptxinfo.l"
+TC; ptxinfo_lval.string_value = strdup(ptxinfo_text); return IDENTIFIER;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 63 "ptxinfo.l"
+TC; ptxinfo_lval.int_value =  atoi(ptxinfo_text); return INT_OPERAND;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 65 "ptxinfo.l"
+TC; return PLUS;
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 66 "ptxinfo.l"
+TC; return COMMA;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 67 "ptxinfo.l"
+TC; return LEFT_SQUARE_BRACKET;
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 68 "ptxinfo.l"
+TC; return RIGHT_SQUARE_BRACKET;
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 69 "ptxinfo.l"
+TC; return COLON;
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 70 "ptxinfo.l"
+TC; return SEMICOLON;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 71 "ptxinfo.l"
+TC; return QUOTE;
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 72 "ptxinfo.l"
+TC;
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 73 "ptxinfo.l"
+TC;
+	YY_BREAK
+case 25:
+/* rule 25 can match eol */
+YY_RULE_SETUP
+#line 75 "ptxinfo.l"
+ptxinfo_col=0; strncpy(ptxinfo_linebuf, ptxinfo_text + 1, 1024); yyless( 1 );
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 77 "ptxinfo.l"
+ECHO;
+	YY_BREAK
+#line 1046 "lex.ptxinfo_.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed ptxinfo_in at a new source and called
+			 * ptxinfo_lex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = ptxinfo_in;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( ptxinfo_wrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * ptxinfo_text, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of ptxinfo_lex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					ptxinfo_realloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			ptxinfo_restart(ptxinfo_in  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) ptxinfo_realloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 137 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 137 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 136);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up ptxinfo_text */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+    if ( c == '\n' ){
+        --ptxinfo_lineno;
+    }
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					ptxinfo_restart(ptxinfo_in );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( ptxinfo_wrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve ptxinfo_text */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	if ( c == '\n' )
+		   
+    ptxinfo_lineno++;
+;
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void ptxinfo_restart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        ptxinfo_ensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            ptxinfo__create_buffer(ptxinfo_in,YY_BUF_SIZE );
+	}
+
+	ptxinfo__init_buffer(YY_CURRENT_BUFFER,input_file );
+	ptxinfo__load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void ptxinfo__switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		ptxinfo_pop_buffer_state();
+	 *		ptxinfo_push_buffer_state(new_buffer);
+     */
+	ptxinfo_ensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	ptxinfo__load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (ptxinfo_wrap()) processing, but the only time this flag
+	 * is looked at is after ptxinfo_wrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void ptxinfo__load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	ptxinfo_in = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE ptxinfo__create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) ptxinfo_alloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in ptxinfo__create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) ptxinfo_alloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in ptxinfo__create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	ptxinfo__init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with ptxinfo__create_buffer()
+ * 
+ */
+    void ptxinfo__delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		ptxinfo_free((void *) b->yy_ch_buf  );
+
+	ptxinfo_free((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a ptxinfo_restart() or at EOF.
+ */
+    static void ptxinfo__init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	ptxinfo__flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then ptxinfo__init_buffer was _probably_
+     * called from ptxinfo_restart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void ptxinfo__flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		ptxinfo__load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void ptxinfo_push_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	ptxinfo_ensure_buffer_stack();
+
+	/* This block is copied from ptxinfo__switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from ptxinfo__switch_to_buffer. */
+	ptxinfo__load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void ptxinfo_pop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	ptxinfo__delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		ptxinfo__load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void ptxinfo_ensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)ptxinfo_alloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in ptxinfo_ensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)ptxinfo_realloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in ptxinfo_ensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE ptxinfo__scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) ptxinfo_alloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in ptxinfo__scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	ptxinfo__switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to ptxinfo_lex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       ptxinfo__scan_bytes() instead.
+ */
+YY_BUFFER_STATE ptxinfo__scan_string (yyconst char * yystr )
+{
+    
+	return ptxinfo__scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to ptxinfo_lex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE ptxinfo__scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) ptxinfo_alloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in ptxinfo__scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = ptxinfo__scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in ptxinfo__scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up ptxinfo_text. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		ptxinfo_text[ptxinfo_leng] = (yy_hold_char); \
+		(yy_c_buf_p) = ptxinfo_text + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		ptxinfo_leng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int ptxinfo_get_lineno  (void)
+{
+        
+    return ptxinfo_lineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *ptxinfo_get_in  (void)
+{
+        return ptxinfo_in;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *ptxinfo_get_out  (void)
+{
+        return ptxinfo_out;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int ptxinfo_get_leng  (void)
+{
+        return ptxinfo_leng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *ptxinfo_get_text  (void)
+{
+        return ptxinfo_text;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void ptxinfo_set_lineno (int  line_number )
+{
+    
+    ptxinfo_lineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see ptxinfo__switch_to_buffer
+ */
+void ptxinfo_set_in (FILE *  in_str )
+{
+        ptxinfo_in = in_str ;
+}
+
+void ptxinfo_set_out (FILE *  out_str )
+{
+        ptxinfo_out = out_str ;
+}
+
+int ptxinfo_get_debug  (void)
+{
+        return ptxinfo__flex_debug;
+}
+
+void ptxinfo_set_debug (int  bdebug )
+{
+        ptxinfo__flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from ptxinfo_lex_destroy(), so don't allocate here.
+     */
+
+    /* We do not touch ptxinfo_lineno unless the option is enabled. */
+    ptxinfo_lineno =  1;
+    
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    ptxinfo_in = stdin;
+    ptxinfo_out = stdout;
+#else
+    ptxinfo_in = (FILE *) 0;
+    ptxinfo_out = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * ptxinfo_lex_init()
+     */
+    return 0;
+}
+
+/* ptxinfo_lex_destroy is for both reentrant and non-reentrant scanners. */
+int ptxinfo_lex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		ptxinfo__delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		ptxinfo_pop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	ptxinfo_free((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * ptxinfo_lex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *ptxinfo_alloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *ptxinfo_realloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void ptxinfo_free (void * ptr )
+{
+	free( (char *) ptr );	/* see ptxinfo_realloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 77 "ptxinfo.l"
+
+
+
+extern int g_ptxinfo_error_detected;
+extern const char *g_filename;
+extern const char *g_ptxinfo_filename;
+
+int ptxinfo_error( const char *s )
+{
+	int i;
+	g_ptxinfo_error_detected = 1;
+	fflush(stdout);
+	printf("GPGPU-Sim: ERROR while parsing output of ptxas (used to capture resource usage information)\n");
+	if( s != NULL )
+		printf("GPGPU-Sim:     %s (%s:%u) Syntax error:\n\n", g_filename, g_ptxinfo_filename, ptxinfo_lineno );
+	printf("   %s\n", ptxinfo_linebuf );
+	printf("   ");
+	for( i=0; i < ptxinfo_col-1; i++ ) {
+		if( ptxinfo_linebuf[i] == '\t' ) printf("\t");
+		else printf(" ");
+	}
+			
+	printf("^\n\n");
+	fflush(stdout);
+	exit(43);
+	return 0;
+}
+
diff --git a/cuda-sim/ptx.tab.c b/cuda-sim/ptx.tab.c
new file mode 100644
--- /dev/null
+++ b/cuda-sim/ptx.tab.c
@@ -0,0 +1,3298 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison implementation for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "3.0.2"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+
+/* Substitute the variable and function names.  */
+#define yyparse         ptx_parse
+#define yylex           ptx_lex
+#define yyerror         ptx_error
+#define yydebug         ptx_debug
+#define yynerrs         ptx_nerrs
+
+#define yylval          ptx_lval
+#define yychar          ptx_char
+
+/* Copy the first part of user declarations.  */
+
+#line 75 "ptx.tab.c" /* yacc.c:339  */
+
+# ifndef YY_NULLPTR
+#  if defined __cplusplus && 201103L <= __cplusplus
+#   define YY_NULLPTR nullptr
+#  else
+#   define YY_NULLPTR 0
+#  endif
+# endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* In a future release of Bison, this section will be replaced
+   by #include "ptx.tab.h".  */
+#ifndef YY_PTX_HOME_CUDA_SIM_PTX_TAB_H_INCLUDED
+# define YY_PTX_HOME_CUDA_SIM_PTX_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int ptx_debug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    STRING = 258,
+    OPCODE = 259,
+    ALIGN_DIRECTIVE = 260,
+    BRANCHTARGETS_DIRECTIVE = 261,
+    BYTE_DIRECTIVE = 262,
+    CALLPROTOTYPE_DIRECTIVE = 263,
+    CALLTARGETS_DIRECTIVE = 264,
+    CONST_DIRECTIVE = 265,
+    CONSTPTR_DIRECTIVE = 266,
+    PTR_DIRECTIVE = 267,
+    ENTRY_DIRECTIVE = 268,
+    EXTERN_DIRECTIVE = 269,
+    FILE_DIRECTIVE = 270,
+    FUNC_DIRECTIVE = 271,
+    GLOBAL_DIRECTIVE = 272,
+    LOCAL_DIRECTIVE = 273,
+    LOC_DIRECTIVE = 274,
+    MAXNCTAPERSM_DIRECTIVE = 275,
+    MAXNNREG_DIRECTIVE = 276,
+    MAXNTID_DIRECTIVE = 277,
+    MINNCTAPERSM_DIRECTIVE = 278,
+    PARAM_DIRECTIVE = 279,
+    PRAGMA_DIRECTIVE = 280,
+    REG_DIRECTIVE = 281,
+    REQNTID_DIRECTIVE = 282,
+    SECTION_DIRECTIVE = 283,
+    SHARED_DIRECTIVE = 284,
+    SREG_DIRECTIVE = 285,
+    STRUCT_DIRECTIVE = 286,
+    SURF_DIRECTIVE = 287,
+    TARGET_DIRECTIVE = 288,
+    TEX_DIRECTIVE = 289,
+    UNION_DIRECTIVE = 290,
+    VERSION_DIRECTIVE = 291,
+    ADDRESS_SIZE_DIRECTIVE = 292,
+    VISIBLE_DIRECTIVE = 293,
+    IDENTIFIER = 294,
+    INT_OPERAND = 295,
+    FLOAT_OPERAND = 296,
+    DOUBLE_OPERAND = 297,
+    S8_TYPE = 298,
+    S16_TYPE = 299,
+    S32_TYPE = 300,
+    S64_TYPE = 301,
+    U8_TYPE = 302,
+    U16_TYPE = 303,
+    U32_TYPE = 304,
+    U64_TYPE = 305,
+    F16_TYPE = 306,
+    F32_TYPE = 307,
+    F64_TYPE = 308,
+    FF64_TYPE = 309,
+    B8_TYPE = 310,
+    B16_TYPE = 311,
+    B32_TYPE = 312,
+    B64_TYPE = 313,
+    BB64_TYPE = 314,
+    BB128_TYPE = 315,
+    PRED_TYPE = 316,
+    TEXREF_TYPE = 317,
+    SAMPLERREF_TYPE = 318,
+    SURFREF_TYPE = 319,
+    V2_TYPE = 320,
+    V3_TYPE = 321,
+    V4_TYPE = 322,
+    COMMA = 323,
+    PRED = 324,
+    HALF_OPTION = 325,
+    EQ_OPTION = 326,
+    NE_OPTION = 327,
+    LT_OPTION = 328,
+    LE_OPTION = 329,
+    GT_OPTION = 330,
+    GE_OPTION = 331,
+    LO_OPTION = 332,
+    LS_OPTION = 333,
+    HI_OPTION = 334,
+    HS_OPTION = 335,
+    EQU_OPTION = 336,
+    NEU_OPTION = 337,
+    LTU_OPTION = 338,
+    LEU_OPTION = 339,
+    GTU_OPTION = 340,
+    GEU_OPTION = 341,
+    NUM_OPTION = 342,
+    NAN_OPTION = 343,
+    CF_OPTION = 344,
+    SF_OPTION = 345,
+    NSF_OPTION = 346,
+    LEFT_SQUARE_BRACKET = 347,
+    RIGHT_SQUARE_BRACKET = 348,
+    WIDE_OPTION = 349,
+    SPECIAL_REGISTER = 350,
+    MINUS = 351,
+    PLUS = 352,
+    COLON = 353,
+    SEMI_COLON = 354,
+    EXCLAMATION = 355,
+    PIPE = 356,
+    RIGHT_BRACE = 357,
+    LEFT_BRACE = 358,
+    EQUALS = 359,
+    PERIOD = 360,
+    BACKSLASH = 361,
+    DIMENSION_MODIFIER = 362,
+    RN_OPTION = 363,
+    RZ_OPTION = 364,
+    RM_OPTION = 365,
+    RP_OPTION = 366,
+    RNI_OPTION = 367,
+    RZI_OPTION = 368,
+    RMI_OPTION = 369,
+    RPI_OPTION = 370,
+    UNI_OPTION = 371,
+    GEOM_MODIFIER_1D = 372,
+    GEOM_MODIFIER_2D = 373,
+    GEOM_MODIFIER_3D = 374,
+    SAT_OPTION = 375,
+    FTZ_OPTION = 376,
+    NEG_OPTION = 377,
+    ATOMIC_AND = 378,
+    ATOMIC_OR = 379,
+    ATOMIC_XOR = 380,
+    ATOMIC_CAS = 381,
+    ATOMIC_EXCH = 382,
+    ATOMIC_ADD = 383,
+    ATOMIC_INC = 384,
+    ATOMIC_DEC = 385,
+    ATOMIC_MIN = 386,
+    ATOMIC_MAX = 387,
+    LEFT_ANGLE_BRACKET = 388,
+    RIGHT_ANGLE_BRACKET = 389,
+    LEFT_PAREN = 390,
+    RIGHT_PAREN = 391,
+    APPROX_OPTION = 392,
+    FULL_OPTION = 393,
+    ANY_OPTION = 394,
+    ALL_OPTION = 395,
+    BALLOT_OPTION = 396,
+    GLOBAL_OPTION = 397,
+    CTA_OPTION = 398,
+    SYS_OPTION = 399,
+    EXIT_OPTION = 400,
+    ABS_OPTION = 401,
+    TO_OPTION = 402,
+    CA_OPTION = 403,
+    CG_OPTION = 404,
+    CS_OPTION = 405,
+    LU_OPTION = 406,
+    CV_OPTION = 407,
+    WB_OPTION = 408,
+    WT_OPTION = 409
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 30 "ptx.y" /* yacc.c:355  */
+
+  double double_value;
+  float  float_value;
+  int    int_value;
+  char * string_value;
+  void * ptr_value;
+
+#line 278 "ptx.tab.c" /* yacc.c:355  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE ptx_lval;
+
+int ptx_parse (void);
+
+#endif /* !YY_PTX_HOME_CUDA_SIM_PTX_TAB_H_INCLUDED  */
+
+/* Copy the second part of user declarations.  */
+#line 194 "ptx.y" /* yacc.c:358  */
+
+  	#include "ptx_parser.h"
+	#include <stdlib.h>
+	#include <string.h>
+	#include <math.h>
+	void syntax_not_implemented();
+	extern int g_func_decl;
+	int ptx_lex(void);
+	int ptx_error(const char *);
+
+#line 303 "ptx.tab.c" /* yacc.c:358  */
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#else
+typedef signed char yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE
+# if (defined __GNUC__                                               \
+      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
+     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
+#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
+# else
+#  define YY_ATTRIBUTE(Spec) /* empty */
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE_PURE
+# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+#endif
+
+#ifndef YY_ATTRIBUTE_UNUSED
+# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
+#endif
+
+#if !defined _Noreturn \
+     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
+# if defined _MSC_VER && 1200 <= _MSC_VER
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(E) ((void) (E))
+#else
+# define YYUSE(E) /* empty */
+#endif
+
+#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define YY_INITIAL_VALUE(Value) Value
+#endif
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYSIZE_T yynewbytes;                                            \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / sizeof (*yyptr);                          \
+      }                                                                 \
+    while (0)
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYSIZE_T yyi;                         \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (0)
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  2
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   598
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  155
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  64
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  268
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  374
+
+/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
+   by yylex, with out-of-bounds checking.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   409
+
+#define YYTRANSLATE(YYX)                                                \
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, without out-of-bounds checking.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
+      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
+      65,    66,    67,    68,    69,    70,    71,    72,    73,    74,
+      75,    76,    77,    78,    79,    80,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,    97,    98,    99,   100,   101,   102,   103,   104,
+     105,   106,   107,   108,   109,   110,   111,   112,   113,   114,
+     115,   116,   117,   118,   119,   120,   121,   122,   123,   124,
+     125,   126,   127,   128,   129,   130,   131,   132,   133,   134,
+     135,   136,   137,   138,   139,   140,   141,   142,   143,   144,
+     145,   146,   147,   148,   149,   150,   151,   152,   153,   154
+};
+
+#if YYDEBUG
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   207,   207,   208,   209,   210,   213,   213,   214,   214,
+     214,   217,   220,   221,   224,   225,   228,   228,   228,   229,
+     229,   230,   233,   233,   233,   234,   237,   238,   239,   240,
+     243,   244,   245,   245,   247,   247,   248,   248,   250,   251,
+     252,   254,   255,   256,   258,   260,   262,   263,   264,   265,
+     266,   267,   270,   271,   272,   273,   274,   275,   276,   277,
+     278,   279,   280,   283,   284,   285,   286,   289,   291,   292,
+     294,   295,   307,   308,   311,   312,   314,   315,   316,   317,
+     320,   322,   323,   324,   327,   328,   329,   330,   331,   332,
+     333,   336,   337,   340,   341,   342,   345,   346,   347,   348,
+     349,   350,   351,   352,   353,   354,   355,   356,   357,   358,
+     359,   360,   361,   362,   363,   364,   365,   366,   369,   370,
+     372,   373,   375,   376,   377,   379,   379,   380,   381,   382,
+     383,   386,   386,   387,   389,   390,   391,   392,   393,   394,
+     395,   396,   397,   398,   399,   400,   401,   404,   405,   407,
+     408,   409,   410,   411,   412,   413,   414,   415,   416,   417,
+     418,   419,   420,   421,   422,   423,   424,   425,   426,   427,
+     428,   429,   430,   431,   432,   433,   434,   435,   436,   437,
+     438,   441,   442,   443,   444,   445,   446,   447,   448,   449,
+     450,   453,   454,   456,   457,   458,   459,   462,   463,   464,
+     465,   468,   469,   470,   471,   472,   473,   474,   475,   476,
+     477,   478,   479,   480,   481,   482,   483,   484,   485,   488,
+     489,   491,   492,   493,   494,   495,   496,   497,   498,   499,
+     500,   501,   502,   503,   504,   505,   506,   507,   508,   509,
+     510,   513,   514,   515,   516,   519,   519,   524,   525,   528,
+     529,   530,   531,   532,   535,   536,   537,   538,   539,   540,
+     541,   544,   545,   546,   549,   550,   551,   552,   553
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || 0
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "STRING", "OPCODE", "ALIGN_DIRECTIVE",
+  "BRANCHTARGETS_DIRECTIVE", "BYTE_DIRECTIVE", "CALLPROTOTYPE_DIRECTIVE",
+  "CALLTARGETS_DIRECTIVE", "CONST_DIRECTIVE", "CONSTPTR_DIRECTIVE",
+  "PTR_DIRECTIVE", "ENTRY_DIRECTIVE", "EXTERN_DIRECTIVE", "FILE_DIRECTIVE",
+  "FUNC_DIRECTIVE", "GLOBAL_DIRECTIVE", "LOCAL_DIRECTIVE", "LOC_DIRECTIVE",
+  "MAXNCTAPERSM_DIRECTIVE", "MAXNNREG_DIRECTIVE", "MAXNTID_DIRECTIVE",
+  "MINNCTAPERSM_DIRECTIVE", "PARAM_DIRECTIVE", "PRAGMA_DIRECTIVE",
+  "REG_DIRECTIVE", "REQNTID_DIRECTIVE", "SECTION_DIRECTIVE",
+  "SHARED_DIRECTIVE", "SREG_DIRECTIVE", "STRUCT_DIRECTIVE",
+  "SURF_DIRECTIVE", "TARGET_DIRECTIVE", "TEX_DIRECTIVE", "UNION_DIRECTIVE",
+  "VERSION_DIRECTIVE", "ADDRESS_SIZE_DIRECTIVE", "VISIBLE_DIRECTIVE",
+  "IDENTIFIER", "INT_OPERAND", "FLOAT_OPERAND", "DOUBLE_OPERAND",
+  "S8_TYPE", "S16_TYPE", "S32_TYPE", "S64_TYPE", "U8_TYPE", "U16_TYPE",
+  "U32_TYPE", "U64_TYPE", "F16_TYPE", "F32_TYPE", "F64_TYPE", "FF64_TYPE",
+  "B8_TYPE", "B16_TYPE", "B32_TYPE", "B64_TYPE", "BB64_TYPE", "BB128_TYPE",
+  "PRED_TYPE", "TEXREF_TYPE", "SAMPLERREF_TYPE", "SURFREF_TYPE", "V2_TYPE",
+  "V3_TYPE", "V4_TYPE", "COMMA", "PRED", "HALF_OPTION", "EQ_OPTION",
+  "NE_OPTION", "LT_OPTION", "LE_OPTION", "GT_OPTION", "GE_OPTION",
+  "LO_OPTION", "LS_OPTION", "HI_OPTION", "HS_OPTION", "EQU_OPTION",
+  "NEU_OPTION", "LTU_OPTION", "LEU_OPTION", "GTU_OPTION", "GEU_OPTION",
+  "NUM_OPTION", "NAN_OPTION", "CF_OPTION", "SF_OPTION", "NSF_OPTION",
+  "LEFT_SQUARE_BRACKET", "RIGHT_SQUARE_BRACKET", "WIDE_OPTION",
+  "SPECIAL_REGISTER", "MINUS", "PLUS", "COLON", "SEMI_COLON",
+  "EXCLAMATION", "PIPE", "RIGHT_BRACE", "LEFT_BRACE", "EQUALS", "PERIOD",
+  "BACKSLASH", "DIMENSION_MODIFIER", "RN_OPTION", "RZ_OPTION", "RM_OPTION",
+  "RP_OPTION", "RNI_OPTION", "RZI_OPTION", "RMI_OPTION", "RPI_OPTION",
+  "UNI_OPTION", "GEOM_MODIFIER_1D", "GEOM_MODIFIER_2D", "GEOM_MODIFIER_3D",
+  "SAT_OPTION", "FTZ_OPTION", "NEG_OPTION", "ATOMIC_AND", "ATOMIC_OR",
+  "ATOMIC_XOR", "ATOMIC_CAS", "ATOMIC_EXCH", "ATOMIC_ADD", "ATOMIC_INC",
+  "ATOMIC_DEC", "ATOMIC_MIN", "ATOMIC_MAX", "LEFT_ANGLE_BRACKET",
+  "RIGHT_ANGLE_BRACKET", "LEFT_PAREN", "RIGHT_PAREN", "APPROX_OPTION",
+  "FULL_OPTION", "ANY_OPTION", "ALL_OPTION", "BALLOT_OPTION",
+  "GLOBAL_OPTION", "CTA_OPTION", "SYS_OPTION", "EXIT_OPTION", "ABS_OPTION",
+  "TO_OPTION", "CA_OPTION", "CG_OPTION", "CS_OPTION", "LU_OPTION",
+  "CV_OPTION", "WB_OPTION", "WT_OPTION", "$accept", "input",
+  "function_defn", "$@1", "$@2", "$@3", "block_spec", "block_spec_list",
+  "function_decl", "$@4", "$@5", "$@6", "function_ident_param", "$@7",
+  "$@8", "function_decl_header", "param_list", "$@9", "param_entry",
+  "$@10", "$@11", "ptr_spec", "ptr_space_spec", "ptr_align_spec",
+  "statement_block", "statement_list", "directive_statement",
+  "variable_declaration", "variable_spec", "identifier_list",
+  "identifier_spec", "var_spec_list", "var_spec", "align_spec",
+  "space_spec", "addressable_spec", "type_spec", "vector_spec",
+  "scalar_type", "initializer_list", "literal_list",
+  "instruction_statement", "instruction", "$@12", "opcode_spec", "$@13",
+  "pred_spec", "option_list", "option", "atomic_operation_spec",
+  "rounding_mode", "floating_point_rounding_mode", "integer_rounding_mode",
+  "compare_spec", "operand_list", "operand", "vector_operand",
+  "tex_operand", "$@14", "builtin_operand", "memory_operand",
+  "twin_operand", "literal_operand", "address_expression", YY_NULLPTR
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[NUM] -- (External) token number corresponding to the
+   (internal) symbol number NUM (which must be that of a token).  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
+     305,   306,   307,   308,   309,   310,   311,   312,   313,   314,
+     315,   316,   317,   318,   319,   320,   321,   322,   323,   324,
+     325,   326,   327,   328,   329,   330,   331,   332,   333,   334,
+     335,   336,   337,   338,   339,   340,   341,   342,   343,   344,
+     345,   346,   347,   348,   349,   350,   351,   352,   353,   354,
+     355,   356,   357,   358,   359,   360,   361,   362,   363,   364,
+     365,   366,   367,   368,   369,   370,   371,   372,   373,   374,
+     375,   376,   377,   378,   379,   380,   381,   382,   383,   384,
+     385,   386,   387,   388,   389,   390,   391,   392,   393,   394,
+     395,   396,   397,   398,   399,   400,   401,   402,   403,   404,
+     405,   406,   407,   408,   409
+};
+# endif
+
+#define YYPACT_NINF -270
+
+#define yypact_value_is_default(Yystate) \
+  (!!((Yystate) == (-270)))
+
+#define YYTABLE_NINF -134
+
+#define yytable_value_is_error(Yytable_value) \
+  0
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+static const yytype_int16 yypact[] =
+{
+    -270,   446,  -270,   -29,  -270,   -33,  -270,     6,   -23,  -270,
+    -270,  -270,    -4,  -270,    89,  -270,  -270,  -270,  -270,    26,
+    -270,   125,   129,   163,  -270,  -270,  -270,  -270,  -270,  -270,
+    -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,
+    -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,
+     -10,   -31,  -270,    99,   170,   509,  -270,  -270,  -270,  -270,
+    -270,   534,  -270,  -270,   144,  -270,   217,   175,   148,   156,
+     146,  -270,  -270,  -270,   130,   184,  -270,   213,  -270,    62,
+     186,   176,  -270,  -270,  -270,   247,  -270,   248,  -270,   250,
+    -270,   287,  -270,   253,   254,   255,  -270,   184,     1,   152,
+    -270,    59,   256,   170,    -8,   222,  -270,   231,   268,   220,
+     -34,   223,  -270,   212,  -270,  -270,   228,   333,   324,  -270,
+     261,  -270,   130,  -270,  -270,  -270,   219,   224,   264,  -270,
+     227,  -270,  -270,  -270,  -270,    -8,  -270,  -270,   318,   323,
+      -3,  -270,   325,   326,  -270,  -270,  -270,  -270,  -270,   312,
+     136,   259,    93,   330,   331,   345,  -270,   308,  -270,  -270,
+    -270,  -270,  -270,   278,   342,  -270,   509,   509,  -270,  -270,
+    -270,  -270,   281,    90,  -270,  -270,  -270,  -270,  -270,  -270,
+    -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,
+    -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,
+    -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,
+    -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,
+    -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,
+    -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,
+    -270,  -270,  -270,    -3,  -270,  -270,  -270,  -270,  -270,  -270,
+    -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,  -270,
+    -270,  -270,  -270,   132,   348,   353,   354,    91,  -270,   301,
+    -270,   126,   200,    -2,  -270,  -270,  -270,    92,   266,   339,
+    -270,   327,   388,   170,   213,     1,  -270,    56,  -270,  -270,
+     -59,  -270,   315,   319,   328,  -270,   131,   134,  -270,  -270,
+    -270,   365,  -270,  -270,  -270,   104,   332,   372,  -270,  -270,
+      61,  -270,   349,   379,   173,   170,  -270,  -270,   -49,  -270,
+    -270,   -16,  -270,  -270,  -270,  -270,  -270,  -270,  -270,   317,
+    -270,    97,   355,  -270,   286,   345,  -270,   386,  -270,  -270,
+    -270,   422,  -270,  -270,  -270,  -270,   142,   243,   337,   393,
+    -270,   345,  -270,  -270,  -270,     1,  -270,  -270,   155,  -270,
+    -270,    98,   370,  -270,  -270,  -270,   404,  -270,   309,   347,
+     345,  -270,   311,  -270
+};
+
+  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+     Performed when YYTABLE does not specify something else to do.  Zero
+     means the default is an error.  */
+static const yytype_uint16 yydefact[] =
+{
+       2,     0,     1,     0,    84,     0,    26,    79,     0,    27,
+      85,    86,     0,    87,     0,    81,    88,    82,    89,     0,
+      90,     0,     0,     0,    96,    97,    98,    99,   100,   101,
+     102,   103,   104,   105,   106,   107,   108,   109,   110,   111,
+     112,   113,   114,   115,   116,   117,    93,    94,    95,     4,
+       5,    21,     3,     0,     0,    67,    74,    78,    76,    83,
+      77,     0,    91,    80,     0,    29,     0,     0,     0,    58,
+      53,    55,    28,    62,     0,     0,    16,     0,    52,    70,
+      63,    68,    79,    75,    92,     0,    59,     0,    61,     0,
+      54,     0,     7,     0,     0,     0,    14,     9,     0,    25,
+      20,     0,     0,     0,     0,     0,    60,    56,   131,     0,
+       0,     0,    51,     0,    46,    47,     0,   130,     0,    13,
+       0,    12,     0,    15,    34,    36,     0,     0,     0,    72,
+       0,    69,   261,   262,   263,     0,    64,    65,     0,     0,
+       0,   123,   134,     0,    45,    50,    48,    49,   122,   221,
+       0,   248,     0,     0,     0,     0,   129,   219,   227,   229,
+     226,   224,   225,     0,     0,    10,     0,     0,    17,    23,
+      73,    71,     0,     0,   120,    66,    57,   173,   201,   202,
+     203,   204,   205,   206,   207,   208,   209,   210,   211,   212,
+     213,   214,   215,   216,   217,   218,   154,   193,   194,   195,
+     196,   197,   198,   199,   200,   153,   161,   162,   163,   164,
+     165,   166,   181,   182,   183,   184,   185,   186,   187,   188,
+     189,   190,   167,   168,   155,   156,   157,   158,   159,   160,
+     169,   170,   172,   174,   175,   176,   177,   178,   179,   180,
+     151,   149,   132,   147,   171,   152,   191,   192,   150,   137,
+     139,   136,   138,   140,   141,   143,   142,   144,   145,   146,
+     135,   231,   233,     0,     0,     0,     0,   264,   268,     0,
+     247,   223,     0,     0,   228,   253,   222,     0,     0,     0,
+     124,     0,    38,     0,     0,    30,   119,     0,   118,   148,
+     264,   261,     0,     0,     0,   230,   235,   238,   245,   265,
+     266,     0,   249,   232,   234,   264,     0,     0,   244,   125,
+       0,   220,   219,     0,     0,     0,    37,    18,     0,    31,
+     121,     0,   252,   251,   250,   236,   237,   239,   240,     0,
+     267,     0,     0,   128,     0,     0,    11,     0,    41,    42,
+      43,     0,    40,    35,    32,    24,   254,     0,     0,     0,
+     241,     0,   127,    44,    39,     0,   255,   256,   257,   260,
+     246,     0,     0,    33,   258,   259,     0,   242,     0,     0,
+       0,   243,     0,   126
+};
+
+  /* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+    -270,  -270,  -270,  -270,  -270,  -270,   356,  -270,   449,  -270,
+    -270,  -270,   168,  -270,  -270,  -270,  -270,  -270,  -269,  -270,
+    -270,  -270,  -270,   113,    64,  -270,    71,  -270,   118,  -270,
+    -101,  -270,   400,  -270,  -270,  -112,  -110,  -270,   397,   334,
+    -270,   360,   359,  -270,  -270,  -270,  -270,   238,  -270,  -270,
+    -270,  -270,  -270,  -270,  -117,  -116,  -149,  -270,  -270,  -270,
+    -143,  -270,  -100,   203
+};
+
+  /* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     1,    49,    74,    75,   122,    96,    97,   111,    98,
+     284,    77,   100,   127,   285,    51,   318,   355,   126,   166,
+     167,   315,   341,   342,    92,   113,    52,    53,    54,    80,
+      81,    55,    56,    57,    58,    59,    60,    61,    62,   136,
+     173,   115,   116,   332,   117,   140,   118,   242,   243,   244,
+     245,   246,   247,   248,   311,   312,   158,   159,   329,   160,
+     161,   292,   162,   269
+};
+
+  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule whose
+     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_int16 yytable[] =
+{
+     156,   157,   131,   274,   137,   142,    64,     4,   -19,   275,
+      -8,    63,    -8,    -8,    10,    11,   319,    66,   299,   344,
+     300,    13,    65,   346,   330,   124,    16,   125,   240,    18,
+     241,    20,   132,   133,   134,   174,    67,   306,   321,   278,
+      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
+      34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
+      44,    45,    46,    47,    48,    69,   143,   177,   178,   179,
+     180,   181,   182,   183,   184,   185,   186,   187,   188,   189,
+     190,   191,   192,   193,   194,   195,   363,   345,   347,    73,
+     272,   196,    68,    -6,   273,   135,   132,   133,   134,   128,
+     149,   132,   133,   134,    76,   197,   198,   199,   200,   201,
+     202,   203,   204,   205,   206,   207,   208,   209,   210,   211,
+     212,   213,   214,   215,   216,   217,   218,   219,   220,   221,
+     275,   240,   271,   241,   222,   223,   224,   225,   226,   227,
+     228,   229,   230,   231,   232,   233,   234,   235,   236,   237,
+     238,   239,   129,   150,   101,   112,   151,   152,   287,   298,
+     307,   153,   114,   293,   154,   349,   366,    70,   299,    71,
+     300,   290,   291,   133,   134,   267,   268,   145,   337,    72,
+     348,   299,   316,   300,   146,   272,   165,   320,   301,   273,
+     338,   339,   288,   334,   308,   102,   154,   333,    78,   350,
+     367,   301,   340,   303,    93,   304,    94,    95,   325,    79,
+     326,   327,    85,   328,   343,    87,   108,     3,   263,   356,
+      86,   357,     4,     5,    89,     6,     7,     8,     9,    10,
+      11,    12,   364,    91,   365,   362,    13,    14,    15,   305,
+     268,    16,    17,    90,    18,    19,    20,    88,    21,    22,
+      23,   109,    99,   372,   103,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    34,    35,    36,    37,    38,
+      39,    40,    41,    42,    43,    44,    45,    46,    47,    48,
+     104,   110,   358,   359,   282,   283,   105,   -22,   106,   107,
+     138,   108,     3,   119,   120,   121,   130,     4,     5,   139,
+       6,     7,     8,     9,    10,    11,    12,  -133,  -133,  -133,
+    -133,    13,    14,    15,   144,    91,    16,    17,   141,    18,
+      19,    20,    73,    21,    22,    23,   109,   148,   108,   164,
+      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
+      34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
+      44,    45,    46,    47,    48,   168,   110,   170,   175,   169,
+    -133,   171,   176,  -133,  -133,   260,   270,  -133,  -133,   276,
+     277,  -133,   149,   132,   133,   134,   279,   280,   149,   132,
+     133,   134,   281,   286,   149,   132,   133,   134,   295,   261,
+      91,   262,   296,   297,   302,   313,   249,   250,   251,   252,
+     314,   253,   309,  -133,   263,   330,   254,   255,   322,   264,
+     256,   331,   323,   265,   257,   258,   259,   335,   266,   336,
+     154,   324,   352,   351,   263,   150,   353,   337,   151,   152,
+     360,   150,   361,   153,   151,   152,   154,   150,   368,   153,
+     151,   152,   154,   369,   370,   153,     2,   373,   154,   371,
+      50,     3,   317,   123,   354,    83,     4,     5,    84,     6,
+       7,     8,     9,    10,    11,    12,   294,     0,   155,   172,
+      13,    14,    15,   147,   310,    16,    17,   163,    18,    19,
+      20,   289,    21,    22,    23,     0,     0,     0,     0,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,     3,     0,     0,     0,     0,     4,
+       0,     0,     0,    82,     0,     0,    10,    11,     0,     0,
+       0,     0,     0,    13,     0,    15,     0,     0,    16,    17,
+       0,    18,     0,    20,     0,     0,     0,     0,     0,     0,
+       0,     0,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    34,    35,    36,    37,    38,    39,    40,    41,
+      42,    43,    44,    45,    46,    47,    48,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    34,    35,    36,
+      37,    38,    39,    40,    41,    42,    43,    44,    45
+};
+
+static const yytype_int16 yycheck[] =
+{
+     117,   117,   103,   152,   104,    39,    39,    10,    39,   152,
+      20,    40,    22,    23,    17,    18,   285,    40,    77,    68,
+      79,    24,    16,    39,    40,    24,    29,    26,   140,    32,
+     140,    34,    40,    41,    42,   135,    40,    39,    97,   155,
+      43,    44,    45,    46,    47,    48,    49,    50,    51,    52,
+      53,    54,    55,    56,    57,    58,    59,    60,    61,    62,
+      63,    64,    65,    66,    67,    39,   100,    70,    71,    72,
+      73,    74,    75,    76,    77,    78,    79,    80,    81,    82,
+      83,    84,    85,    86,    87,    88,   355,   136,   104,    99,
+      92,    94,     3,   103,    96,   103,    40,    41,    42,    40,
+      39,    40,    41,    42,   135,   108,   109,   110,   111,   112,
+     113,   114,   115,   116,   117,   118,   119,   120,   121,   122,
+     123,   124,   125,   126,   127,   128,   129,   130,   131,   132,
+     273,   243,    39,   243,   137,   138,   139,   140,   141,   142,
+     143,   144,   145,   146,   147,   148,   149,   150,   151,   152,
+     153,   154,    93,    92,    92,    91,    95,    96,    68,    68,
+      68,   100,    91,   263,   103,    68,    68,    42,    77,    40,
+      79,    39,    40,    41,    42,    39,    40,   113,     5,    16,
+     329,    77,   283,    79,   113,    92,   122,   287,    97,    96,
+      17,    18,   102,   310,   102,   133,   103,   136,    99,   102,
+     102,    97,    29,    77,    20,    79,    22,    23,    77,    39,
+      79,    77,    68,    79,   315,    40,     4,     5,    92,    77,
+       3,    79,    10,    11,    68,    13,    14,    15,    16,    17,
+      18,    19,    77,   103,    79,   351,    24,    25,    26,    39,
+      40,    29,    30,    97,    32,    33,    34,    99,    36,    37,
+      38,    39,    39,   370,    68,    43,    44,    45,    46,    47,
+      48,    49,    50,    51,    52,    53,    54,    55,    56,    57,
+      58,    59,    60,    61,    62,    63,    64,    65,    66,    67,
+     104,    69,    39,    40,   166,   167,    39,   135,    40,    39,
+      68,     4,     5,    40,    40,    40,    40,    10,    11,    68,
+      13,    14,    15,    16,    17,    18,    19,    39,    40,    41,
+      42,    24,    25,    26,   102,   103,    29,    30,    98,    32,
+      33,    34,    99,    36,    37,    38,    39,    99,     4,    68,
+      43,    44,    45,    46,    47,    48,    49,    50,    51,    52,
+      53,    54,    55,    56,    57,    58,    59,    60,    61,    62,
+      63,    64,    65,    66,    67,   136,    69,    93,    40,   135,
+      92,   134,    39,    95,    96,    39,   107,    99,   100,    39,
+      39,   103,    39,    40,    41,    42,    68,    99,    39,    40,
+      41,    42,    40,   102,    39,    40,    41,    42,    40,    77,
+     103,    79,    39,    39,    93,    68,    71,    72,    73,    74,
+      12,    76,   136,   135,    92,    40,    81,    82,    93,    97,
+      85,    39,    93,   101,    89,    90,    91,    68,   106,    40,
+     103,    93,   136,    68,    92,    92,    40,     5,    95,    96,
+      93,    92,    39,   100,    95,    96,   103,    92,    68,   100,
+      95,    96,   103,    39,   135,   100,     0,   136,   103,   102,
+       1,     5,   284,    97,   341,    55,    10,    11,    61,    13,
+      14,    15,    16,    17,    18,    19,   263,    -1,   135,   135,
+      24,    25,    26,   113,   135,    29,    30,   118,    32,    33,
+      34,   243,    36,    37,    38,    -1,    -1,    -1,    -1,    43,
+      44,    45,    46,    47,    48,    49,    50,    51,    52,    53,
+      54,    55,    56,    57,    58,    59,    60,    61,    62,    63,
+      64,    65,    66,    67,     5,    -1,    -1,    -1,    -1,    10,
+      -1,    -1,    -1,    14,    -1,    -1,    17,    18,    -1,    -1,
+      -1,    -1,    -1,    24,    -1,    26,    -1,    -1,    29,    30,
+      -1,    32,    -1,    34,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    43,    44,    45,    46,    47,    48,    49,    50,
+      51,    52,    53,    54,    55,    56,    57,    58,    59,    60,
+      61,    62,    63,    64,    65,    66,    67,    43,    44,    45,
+      46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
+      56,    57,    58,    59,    60,    61,    62,    63,    64
+};
+
+  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,   156,     0,     5,    10,    11,    13,    14,    15,    16,
+      17,    18,    19,    24,    25,    26,    29,    30,    32,    33,
+      34,    36,    37,    38,    43,    44,    45,    46,    47,    48,
+      49,    50,    51,    52,    53,    54,    55,    56,    57,    58,
+      59,    60,    61,    62,    63,    64,    65,    66,    67,   157,
+     163,   170,   181,   182,   183,   186,   187,   188,   189,   190,
+     191,   192,   193,    40,    39,    16,    40,    40,     3,    39,
+      42,    40,    16,    99,   158,   159,   135,   166,    99,    39,
+     184,   185,    14,   187,   193,    68,     3,    40,    99,    68,
+      97,   103,   179,    20,    22,    23,   161,   162,   164,    39,
+     167,    92,   133,    68,   104,    39,    40,    39,     4,    39,
+      69,   163,   179,   180,   181,   196,   197,   199,   201,    40,
+      40,    40,   160,   161,    24,    26,   173,   168,    40,    93,
+      40,   185,    40,    41,    42,   103,   194,   217,    68,    68,
+     200,    98,    39,   100,   102,   179,   181,   196,    99,    39,
+      92,    95,    96,   100,   103,   135,   209,   210,   211,   212,
+     214,   215,   217,   197,    68,   179,   174,   175,   136,   135,
+      93,   134,   194,   195,   217,    40,    39,    70,    71,    72,
+      73,    74,    75,    76,    77,    78,    79,    80,    81,    82,
+      83,    84,    85,    86,    87,    88,    94,   108,   109,   110,
+     111,   112,   113,   114,   115,   116,   117,   118,   119,   120,
+     121,   122,   123,   124,   125,   126,   127,   128,   129,   130,
+     131,   132,   137,   138,   139,   140,   141,   142,   143,   144,
+     145,   146,   147,   148,   149,   150,   151,   152,   153,   154,
+     190,   191,   202,   203,   204,   205,   206,   207,   208,    71,
+      72,    73,    74,    76,    81,    82,    85,    89,    90,    91,
+      39,    77,    79,    92,    97,   101,   106,    39,    40,   218,
+     107,    39,    92,    96,   211,   215,    39,    39,   210,    68,
+      99,    40,   183,   183,   165,   169,   102,    68,   102,   202,
+      39,    40,   216,   217,   218,    40,    39,    39,    68,    77,
+      79,    97,    93,    77,    79,    39,    39,    68,   102,   136,
+     135,   209,   210,    68,    12,   176,   185,   167,   171,   173,
+     217,    97,    93,    93,    93,    77,    79,    77,    79,   213,
+      40,    39,   198,   136,   209,    68,    40,     5,    17,    18,
+      29,   177,   178,   185,    68,   136,    39,   104,   211,    68,
+     102,    68,   136,    40,   178,   172,    77,    79,    39,    40,
+      93,    39,   210,   173,    77,    79,    68,   102,    68,    39,
+     135,   102,   209,   136
+};
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,   155,   156,   156,   156,   156,   158,   157,   159,   160,
+     157,   161,   161,   161,   162,   162,   164,   165,   163,   166,
+     163,   163,   168,   169,   167,   167,   170,   170,   170,   170,
+     171,   171,   172,   171,   174,   173,   175,   173,   176,   176,
+     176,   177,   177,   177,   178,   179,   180,   180,   180,   180,
+     180,   180,   181,   181,   181,   181,   181,   181,   181,   181,
+     181,   181,   181,   182,   182,   182,   182,   183,   184,   184,
+     185,   185,   185,   185,   186,   186,   187,   187,   187,   187,
+     188,   189,   189,   189,   190,   190,   190,   190,   190,   190,
+     190,   191,   191,   192,   192,   192,   193,   193,   193,   193,
+     193,   193,   193,   193,   193,   193,   193,   193,   193,   193,
+     193,   193,   193,   193,   193,   193,   193,   193,   194,   194,
+     195,   195,   196,   196,   196,   198,   197,   197,   197,   197,
+     197,   200,   199,   199,   201,   201,   201,   201,   201,   201,
+     201,   201,   201,   201,   201,   201,   201,   202,   202,   203,
+     203,   203,   203,   203,   203,   203,   203,   203,   203,   203,
+     203,   203,   203,   203,   203,   203,   203,   203,   203,   203,
+     203,   203,   203,   203,   203,   203,   203,   203,   203,   203,
+     203,   204,   204,   204,   204,   204,   204,   204,   204,   204,
+     204,   205,   205,   206,   206,   206,   206,   207,   207,   207,
+     207,   208,   208,   208,   208,   208,   208,   208,   208,   208,
+     208,   208,   208,   208,   208,   208,   208,   208,   208,   209,
+     209,   210,   210,   210,   210,   210,   210,   210,   210,   210,
+     210,   210,   210,   210,   210,   210,   210,   210,   210,   210,
+     210,   211,   211,   211,   211,   213,   212,   214,   214,   215,
+     215,   215,   215,   215,   216,   216,   216,   216,   216,   216,
+     216,   217,   217,   217,   218,   218,   218,   218,   218
+};
+
+  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     2,     2,     2,     0,     3,     0,     0,
+       5,     6,     2,     2,     1,     2,     0,     0,     7,     0,
+       3,     1,     0,     0,     6,     1,     1,     1,     2,     2,
+       0,     1,     0,     4,     0,     5,     0,     4,     0,     3,
+       2,     1,     1,     1,     2,     3,     1,     1,     2,     2,
+       2,     1,     2,     2,     3,     2,     4,     6,     2,     3,
+       4,     3,     2,     2,     4,     4,     6,     1,     1,     3,
+       1,     4,     3,     4,     1,     2,     1,     1,     1,     1,
+       2,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     2,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     3,     3,
+       1,     3,     2,     2,     3,     0,    11,     6,     5,     2,
+       1,     0,     3,     1,     2,     3,     3,     3,     3,     3,
+       3,     3,     3,     3,     3,     3,     3,     1,     2,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       3,     1,     2,     2,     1,     1,     1,     1,     2,     1,
+       3,     2,     3,     2,     3,     3,     4,     4,     3,     4,
+       4,     5,     7,     9,     3,     0,     6,     2,     1,     3,
+       4,     4,     4,     2,     3,     4,     4,     4,     5,     5,
+       4,     1,     1,     1,     1,     2,     2,     3,     1
+};
+
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+#define YYEMPTY         (-2)
+#define YYEOF           0
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                  \
+do                                                              \
+  if (yychar == YYEMPTY)                                        \
+    {                                                           \
+      yychar = (Token);                                         \
+      yylval = (Value);                                         \
+      YYPOPSTACK (yylen);                                       \
+      yystate = *yyssp;                                         \
+      goto yybackup;                                            \
+    }                                                           \
+  else                                                          \
+    {                                                           \
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;                                                  \
+    }                                                           \
+while (0)
+
+/* Error token number */
+#define YYTERROR        1
+#define YYERRCODE       256
+
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
+
+/* This macro is provided for backward compatibility. */
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Type, Value); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+
+/*----------------------------------------.
+| Print this symbol's value on YYOUTPUT.  |
+`----------------------------------------*/
+
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  FILE *yyo = yyoutput;
+  YYUSE (yyo);
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  YYUSE (yytype);
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  YYFPRINTF (yyoutput, "%s %s (",
+             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+static void
+yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
+{
+  unsigned long int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+             yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       yystos[yyssp[yyi + 1 - yynrhs]],
+                       &(yyvsp[(yyi + 1) - (yynrhs)])
+                                              );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, Rule); \
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+yystrlen (const char *yystr)
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            /* Fall through.  */
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULLPTR;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                {
+                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
+                  if (! (yysize <= yysize1
+                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                    return 2;
+                  yysize = yysize1;
+                }
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  {
+    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
+    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+      return 2;
+    yysize = yysize1;
+  }
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+{
+  YYUSE (yyvaluep);
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
+
+
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+int
+yyparse (void)
+{
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       'yyss': related to states.
+       'yyvs': related to semantic values.
+
+       Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yyssp = yyss = yyssa;
+  yyvsp = yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        YYSTYPE *yyvs1 = yyvs;
+        yytype_int16 *yyss1 = yyss;
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * sizeof (*yyssp),
+                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yystacksize);
+
+        yyss = yyss1;
+        yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+        goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
+
+      {
+        yytype_int16 *yyss1 = yyss;
+        union yyalloc *yyptr =
+          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+        if (! yyptr)
+          goto yyexhaustedlab;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+                  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = yylex ();
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     '$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 6:
+#line 213 "ptx.y" /* yacc.c:1646  */
+    { set_symtab((yyvsp[0].ptr_value)); func_header(".skip"); }
+#line 1765 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 7:
+#line 213 "ptx.y" /* yacc.c:1646  */
+    { end_function(); }
+#line 1771 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 8:
+#line 214 "ptx.y" /* yacc.c:1646  */
+    { set_symtab((yyvsp[0].ptr_value)); }
+#line 1777 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 9:
+#line 214 "ptx.y" /* yacc.c:1646  */
+    { func_header(".skip"); }
+#line 1783 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 10:
+#line 214 "ptx.y" /* yacc.c:1646  */
+    { end_function(); }
+#line 1789 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 11:
+#line 217 "ptx.y" /* yacc.c:1646  */
+    {func_header_info_int(".maxntid", (yyvsp[-4].int_value));
+										func_header_info_int(",", (yyvsp[-2].int_value));
+										func_header_info_int(",", (yyvsp[0].int_value)); }
+#line 1797 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 12:
+#line 220 "ptx.y" /* yacc.c:1646  */
+    { func_header_info_int(".minnctapersm", (yyvsp[0].int_value)); printf("GPGPU-Sim: Warning: .minnctapersm ignored. \n"); }
+#line 1803 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 13:
+#line 221 "ptx.y" /* yacc.c:1646  */
+    { func_header_info_int(".maxnctapersm", (yyvsp[0].int_value)); printf("GPGPU-Sim: Warning: .maxnctapersm ignored. \n"); }
+#line 1809 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 16:
+#line 228 "ptx.y" /* yacc.c:1646  */
+    { start_function((yyvsp[-1].int_value)); func_header_info("(");}
+#line 1815 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 17:
+#line 228 "ptx.y" /* yacc.c:1646  */
+    {func_header_info(")");}
+#line 1821 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 18:
+#line 228 "ptx.y" /* yacc.c:1646  */
+    { (yyval.ptr_value) = reset_symtab(); }
+#line 1827 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 19:
+#line 229 "ptx.y" /* yacc.c:1646  */
+    { start_function((yyvsp[0].int_value)); }
+#line 1833 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 20:
+#line 229 "ptx.y" /* yacc.c:1646  */
+    { (yyval.ptr_value) = reset_symtab(); }
+#line 1839 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 21:
+#line 230 "ptx.y" /* yacc.c:1646  */
+    { start_function((yyvsp[0].int_value)); add_function_name(""); g_func_decl=0; (yyval.ptr_value) = reset_symtab(); }
+#line 1845 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 22:
+#line 233 "ptx.y" /* yacc.c:1646  */
+    { add_function_name((yyvsp[0].string_value)); }
+#line 1851 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 23:
+#line 233 "ptx.y" /* yacc.c:1646  */
+    {func_header_info("(");}
+#line 1857 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 24:
+#line 233 "ptx.y" /* yacc.c:1646  */
+    { g_func_decl=0; func_header_info(")"); }
+#line 1863 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 25:
+#line 234 "ptx.y" /* yacc.c:1646  */
+    { add_function_name((yyvsp[0].string_value)); g_func_decl=0; }
+#line 1869 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 26:
+#line 237 "ptx.y" /* yacc.c:1646  */
+    { (yyval.int_value) = 1; g_func_decl=1; func_header(".entry"); }
+#line 1875 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 27:
+#line 238 "ptx.y" /* yacc.c:1646  */
+    { (yyval.int_value) = 0; g_func_decl=1; func_header(".func"); }
+#line 1881 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 28:
+#line 239 "ptx.y" /* yacc.c:1646  */
+    { (yyval.int_value) = 0; g_func_decl=1; func_header(".func"); }
+#line 1887 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 29:
+#line 240 "ptx.y" /* yacc.c:1646  */
+    { (yyval.int_value) = 2; g_func_decl=1; func_header(".func"); }
+#line 1893 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 31:
+#line 244 "ptx.y" /* yacc.c:1646  */
+    { add_directive(); }
+#line 1899 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 32:
+#line 245 "ptx.y" /* yacc.c:1646  */
+    {func_header_info(",");}
+#line 1905 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 33:
+#line 245 "ptx.y" /* yacc.c:1646  */
+    { add_directive(); }
+#line 1911 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 34:
+#line 247 "ptx.y" /* yacc.c:1646  */
+    { add_space_spec(param_space_unclassified,0); }
+#line 1917 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 35:
+#line 247 "ptx.y" /* yacc.c:1646  */
+    { add_function_arg(); }
+#line 1923 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 36:
+#line 248 "ptx.y" /* yacc.c:1646  */
+    { add_space_spec(reg_space,0); }
+#line 1929 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 37:
+#line 248 "ptx.y" /* yacc.c:1646  */
+    { add_function_arg(); }
+#line 1935 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 41:
+#line 254 "ptx.y" /* yacc.c:1646  */
+    { add_ptr_spec(global_space); }
+#line 1941 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 42:
+#line 255 "ptx.y" /* yacc.c:1646  */
+    { add_ptr_spec(local_space); }
+#line 1947 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 43:
+#line 256 "ptx.y" /* yacc.c:1646  */
+    { add_ptr_spec(shared_space); }
+#line 1953 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 46:
+#line 262 "ptx.y" /* yacc.c:1646  */
+    { add_directive(); }
+#line 1959 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 47:
+#line 263 "ptx.y" /* yacc.c:1646  */
+    { add_instruction(); }
+#line 1965 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 48:
+#line 264 "ptx.y" /* yacc.c:1646  */
+    { add_directive(); }
+#line 1971 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 49:
+#line 265 "ptx.y" /* yacc.c:1646  */
+    { add_instruction(); }
+#line 1977 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 53:
+#line 271 "ptx.y" /* yacc.c:1646  */
+    { add_version_info((yyvsp[0].double_value), 0); }
+#line 1983 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 54:
+#line 272 "ptx.y" /* yacc.c:1646  */
+    { add_version_info((yyvsp[-1].double_value),1); }
+#line 1989 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 55:
+#line 273 "ptx.y" /* yacc.c:1646  */
+    {/*Do nothing*/}
+#line 1995 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 56:
+#line 274 "ptx.y" /* yacc.c:1646  */
+    { target_header2((yyvsp[-2].string_value),(yyvsp[0].string_value)); }
+#line 2001 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 57:
+#line 275 "ptx.y" /* yacc.c:1646  */
+    { target_header3((yyvsp[-4].string_value),(yyvsp[-2].string_value),(yyvsp[0].string_value)); }
+#line 2007 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 58:
+#line 276 "ptx.y" /* yacc.c:1646  */
+    { target_header((yyvsp[0].string_value)); }
+#line 2013 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 59:
+#line 277 "ptx.y" /* yacc.c:1646  */
+    { add_file((yyvsp[-1].int_value),(yyvsp[0].string_value)); }
+#line 2019 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 61:
+#line 279 "ptx.y" /* yacc.c:1646  */
+    { add_pragma((yyvsp[-1].string_value)); }
+#line 2025 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 62:
+#line 280 "ptx.y" /* yacc.c:1646  */
+    {/*Do nothing*/}
+#line 2031 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 63:
+#line 283 "ptx.y" /* yacc.c:1646  */
+    { add_variables(); }
+#line 2037 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 64:
+#line 284 "ptx.y" /* yacc.c:1646  */
+    { add_variables(); }
+#line 2043 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 65:
+#line 285 "ptx.y" /* yacc.c:1646  */
+    { add_variables(); }
+#line 2049 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 66:
+#line 286 "ptx.y" /* yacc.c:1646  */
+    { add_constptr((yyvsp[-4].string_value), (yyvsp[-2].string_value), (yyvsp[0].int_value)); }
+#line 2055 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 67:
+#line 289 "ptx.y" /* yacc.c:1646  */
+    { set_variable_type(); }
+#line 2061 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 70:
+#line 294 "ptx.y" /* yacc.c:1646  */
+    { add_identifier((yyvsp[0].string_value),0,NON_ARRAY_IDENTIFIER); func_header_info((yyvsp[0].string_value));}
+#line 2067 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 71:
+#line 295 "ptx.y" /* yacc.c:1646  */
+    { func_header_info((yyvsp[-3].string_value)); func_header_info_int("<", (yyvsp[-1].int_value)); func_header_info(">");
+		int i,lbase,l;
+		char *id = NULL;
+		lbase = strlen((yyvsp[-3].string_value));
+		for( i=0; i < (yyvsp[-1].int_value); i++ ) { 
+			l = lbase + (int)log10(i+1)+10;
+			id = (char*) malloc(l);
+			snprintf(id,l,"%s%u",(yyvsp[-3].string_value),i);
+			add_identifier(id,0,NON_ARRAY_IDENTIFIER); 
+		}
+		free((yyvsp[-3].string_value));
+	}
+#line 2084 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 72:
+#line 307 "ptx.y" /* yacc.c:1646  */
+    { add_identifier((yyvsp[-2].string_value),0,ARRAY_IDENTIFIER_NO_DIM); func_header_info((yyvsp[-2].string_value)); func_header_info("["); func_header_info("]");}
+#line 2090 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 73:
+#line 308 "ptx.y" /* yacc.c:1646  */
+    { add_identifier((yyvsp[-3].string_value),(yyvsp[-1].int_value),ARRAY_IDENTIFIER); func_header_info((yyvsp[-3].string_value)); func_header_info_int("[",(yyvsp[-1].int_value)); func_header_info("]");}
+#line 2096 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 79:
+#line 317 "ptx.y" /* yacc.c:1646  */
+    { add_extern_spec(); }
+#line 2102 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 80:
+#line 320 "ptx.y" /* yacc.c:1646  */
+    { add_alignment_spec((yyvsp[0].int_value)); }
+#line 2108 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 81:
+#line 322 "ptx.y" /* yacc.c:1646  */
+    {  add_space_spec(reg_space,0); }
+#line 2114 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 82:
+#line 323 "ptx.y" /* yacc.c:1646  */
+    {  add_space_spec(reg_space,0); }
+#line 2120 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 84:
+#line 327 "ptx.y" /* yacc.c:1646  */
+    {  add_space_spec(const_space,(yyvsp[0].int_value)); }
+#line 2126 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 85:
+#line 328 "ptx.y" /* yacc.c:1646  */
+    {  add_space_spec(global_space,0); }
+#line 2132 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 86:
+#line 329 "ptx.y" /* yacc.c:1646  */
+    {  add_space_spec(local_space,0); }
+#line 2138 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 87:
+#line 330 "ptx.y" /* yacc.c:1646  */
+    {  add_space_spec(param_space_unclassified,0); }
+#line 2144 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 88:
+#line 331 "ptx.y" /* yacc.c:1646  */
+    {  add_space_spec(shared_space,0); }
+#line 2150 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 89:
+#line 332 "ptx.y" /* yacc.c:1646  */
+    {  add_space_spec(surf_space,0); }
+#line 2156 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 90:
+#line 333 "ptx.y" /* yacc.c:1646  */
+    {  add_space_spec(tex_space,0); }
+#line 2162 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 93:
+#line 340 "ptx.y" /* yacc.c:1646  */
+    {  add_option(V2_TYPE); func_header_info(".v2");}
+#line 2168 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 94:
+#line 341 "ptx.y" /* yacc.c:1646  */
+    {  add_option(V3_TYPE); func_header_info(".v3");}
+#line 2174 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 95:
+#line 342 "ptx.y" /* yacc.c:1646  */
+    {  add_option(V4_TYPE); func_header_info(".v4");}
+#line 2180 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 96:
+#line 345 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( S8_TYPE ); }
+#line 2186 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 97:
+#line 346 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( S16_TYPE ); }
+#line 2192 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 98:
+#line 347 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( S32_TYPE ); }
+#line 2198 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 99:
+#line 348 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( S64_TYPE ); }
+#line 2204 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 100:
+#line 349 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( U8_TYPE ); }
+#line 2210 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 101:
+#line 350 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( U16_TYPE ); }
+#line 2216 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 102:
+#line 351 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( U32_TYPE ); }
+#line 2222 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 103:
+#line 352 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( U64_TYPE ); }
+#line 2228 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 104:
+#line 353 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( F16_TYPE ); }
+#line 2234 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 105:
+#line 354 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( F32_TYPE ); }
+#line 2240 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 106:
+#line 355 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( F64_TYPE ); }
+#line 2246 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 107:
+#line 356 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( FF64_TYPE ); }
+#line 2252 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 108:
+#line 357 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( B8_TYPE );  }
+#line 2258 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 109:
+#line 358 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( B16_TYPE ); }
+#line 2264 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 110:
+#line 359 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( B32_TYPE ); }
+#line 2270 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 111:
+#line 360 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( B64_TYPE ); }
+#line 2276 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 112:
+#line 361 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( BB64_TYPE ); }
+#line 2282 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 113:
+#line 362 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( BB128_TYPE ); }
+#line 2288 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 114:
+#line 363 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( PRED_TYPE ); }
+#line 2294 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 115:
+#line 364 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( TEXREF_TYPE ); }
+#line 2300 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 116:
+#line 365 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( SAMPLERREF_TYPE ); }
+#line 2306 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 117:
+#line 366 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_type_spec( SURFREF_TYPE ); }
+#line 2312 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 118:
+#line 369 "ptx.y" /* yacc.c:1646  */
+    { add_array_initializer(); }
+#line 2318 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 119:
+#line 370 "ptx.y" /* yacc.c:1646  */
+    { syntax_not_implemented(); }
+#line 2324 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 123:
+#line 376 "ptx.y" /* yacc.c:1646  */
+    { add_label((yyvsp[-1].string_value)); }
+#line 2330 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 125:
+#line 379 "ptx.y" /* yacc.c:1646  */
+    { set_return(); }
+#line 2336 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 131:
+#line 386 "ptx.y" /* yacc.c:1646  */
+    { add_opcode((yyvsp[0].int_value)); }
+#line 2342 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 133:
+#line 387 "ptx.y" /* yacc.c:1646  */
+    { add_opcode((yyvsp[0].int_value)); }
+#line 2348 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 134:
+#line 389 "ptx.y" /* yacc.c:1646  */
+    { add_pred((yyvsp[0].string_value),0, -1); }
+#line 2354 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 135:
+#line 390 "ptx.y" /* yacc.c:1646  */
+    { add_pred((yyvsp[0].string_value),1, -1); }
+#line 2360 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 136:
+#line 391 "ptx.y" /* yacc.c:1646  */
+    { add_pred((yyvsp[-1].string_value),0,1); }
+#line 2366 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 137:
+#line 392 "ptx.y" /* yacc.c:1646  */
+    { add_pred((yyvsp[-1].string_value),0,2); }
+#line 2372 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 138:
+#line 393 "ptx.y" /* yacc.c:1646  */
+    { add_pred((yyvsp[-1].string_value),0,3); }
+#line 2378 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 139:
+#line 394 "ptx.y" /* yacc.c:1646  */
+    { add_pred((yyvsp[-1].string_value),0,5); }
+#line 2384 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 140:
+#line 395 "ptx.y" /* yacc.c:1646  */
+    { add_pred((yyvsp[-1].string_value),0,6); }
+#line 2390 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 141:
+#line 396 "ptx.y" /* yacc.c:1646  */
+    { add_pred((yyvsp[-1].string_value),0,10); }
+#line 2396 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 142:
+#line 397 "ptx.y" /* yacc.c:1646  */
+    { add_pred((yyvsp[-1].string_value),0,12); }
+#line 2402 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 143:
+#line 398 "ptx.y" /* yacc.c:1646  */
+    { add_pred((yyvsp[-1].string_value),0,13); }
+#line 2408 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 144:
+#line 399 "ptx.y" /* yacc.c:1646  */
+    { add_pred((yyvsp[-1].string_value),0,17); }
+#line 2414 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 145:
+#line 400 "ptx.y" /* yacc.c:1646  */
+    { add_pred((yyvsp[-1].string_value),0,19); }
+#line 2420 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 146:
+#line 401 "ptx.y" /* yacc.c:1646  */
+    { add_pred((yyvsp[-1].string_value),0,28); }
+#line 2426 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 153:
+#line 411 "ptx.y" /* yacc.c:1646  */
+    { add_option(UNI_OPTION); }
+#line 2432 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 154:
+#line 412 "ptx.y" /* yacc.c:1646  */
+    { add_option(WIDE_OPTION); }
+#line 2438 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 155:
+#line 413 "ptx.y" /* yacc.c:1646  */
+    { add_option(ANY_OPTION); }
+#line 2444 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 156:
+#line 414 "ptx.y" /* yacc.c:1646  */
+    { add_option(ALL_OPTION); }
+#line 2450 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 157:
+#line 415 "ptx.y" /* yacc.c:1646  */
+    { add_option(BALLOT_OPTION); }
+#line 2456 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 158:
+#line 416 "ptx.y" /* yacc.c:1646  */
+    { add_option(GLOBAL_OPTION); }
+#line 2462 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 159:
+#line 417 "ptx.y" /* yacc.c:1646  */
+    { add_option(CTA_OPTION); }
+#line 2468 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 160:
+#line 418 "ptx.y" /* yacc.c:1646  */
+    { add_option(SYS_OPTION); }
+#line 2474 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 161:
+#line 419 "ptx.y" /* yacc.c:1646  */
+    { add_option(GEOM_MODIFIER_1D); }
+#line 2480 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 162:
+#line 420 "ptx.y" /* yacc.c:1646  */
+    { add_option(GEOM_MODIFIER_2D); }
+#line 2486 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 163:
+#line 421 "ptx.y" /* yacc.c:1646  */
+    { add_option(GEOM_MODIFIER_3D); }
+#line 2492 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 164:
+#line 422 "ptx.y" /* yacc.c:1646  */
+    { add_option(SAT_OPTION); }
+#line 2498 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 165:
+#line 423 "ptx.y" /* yacc.c:1646  */
+    { add_option(FTZ_OPTION); }
+#line 2504 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 166:
+#line 424 "ptx.y" /* yacc.c:1646  */
+    { add_option(NEG_OPTION); }
+#line 2510 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 167:
+#line 425 "ptx.y" /* yacc.c:1646  */
+    { add_option(APPROX_OPTION); }
+#line 2516 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 168:
+#line 426 "ptx.y" /* yacc.c:1646  */
+    { add_option(FULL_OPTION); }
+#line 2522 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 169:
+#line 427 "ptx.y" /* yacc.c:1646  */
+    { add_option(EXIT_OPTION); }
+#line 2528 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 170:
+#line 428 "ptx.y" /* yacc.c:1646  */
+    { add_option(ABS_OPTION); }
+#line 2534 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 172:
+#line 430 "ptx.y" /* yacc.c:1646  */
+    { add_option(TO_OPTION); }
+#line 2540 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 173:
+#line 431 "ptx.y" /* yacc.c:1646  */
+    { add_option(HALF_OPTION); }
+#line 2546 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 174:
+#line 432 "ptx.y" /* yacc.c:1646  */
+    { add_option(CA_OPTION); }
+#line 2552 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 175:
+#line 433 "ptx.y" /* yacc.c:1646  */
+    { add_option(CG_OPTION); }
+#line 2558 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 176:
+#line 434 "ptx.y" /* yacc.c:1646  */
+    { add_option(CS_OPTION); }
+#line 2564 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 177:
+#line 435 "ptx.y" /* yacc.c:1646  */
+    { add_option(LU_OPTION); }
+#line 2570 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 178:
+#line 436 "ptx.y" /* yacc.c:1646  */
+    { add_option(CV_OPTION); }
+#line 2576 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 179:
+#line 437 "ptx.y" /* yacc.c:1646  */
+    { add_option(WB_OPTION); }
+#line 2582 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 180:
+#line 438 "ptx.y" /* yacc.c:1646  */
+    { add_option(WT_OPTION); }
+#line 2588 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 181:
+#line 441 "ptx.y" /* yacc.c:1646  */
+    { add_option(ATOMIC_AND); }
+#line 2594 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 182:
+#line 442 "ptx.y" /* yacc.c:1646  */
+    { add_option(ATOMIC_OR); }
+#line 2600 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 183:
+#line 443 "ptx.y" /* yacc.c:1646  */
+    { add_option(ATOMIC_XOR); }
+#line 2606 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 184:
+#line 444 "ptx.y" /* yacc.c:1646  */
+    { add_option(ATOMIC_CAS); }
+#line 2612 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 185:
+#line 445 "ptx.y" /* yacc.c:1646  */
+    { add_option(ATOMIC_EXCH); }
+#line 2618 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 186:
+#line 446 "ptx.y" /* yacc.c:1646  */
+    { add_option(ATOMIC_ADD); }
+#line 2624 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 187:
+#line 447 "ptx.y" /* yacc.c:1646  */
+    { add_option(ATOMIC_INC); }
+#line 2630 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 188:
+#line 448 "ptx.y" /* yacc.c:1646  */
+    { add_option(ATOMIC_DEC); }
+#line 2636 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 189:
+#line 449 "ptx.y" /* yacc.c:1646  */
+    { add_option(ATOMIC_MIN); }
+#line 2642 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 190:
+#line 450 "ptx.y" /* yacc.c:1646  */
+    { add_option(ATOMIC_MAX); }
+#line 2648 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 193:
+#line 456 "ptx.y" /* yacc.c:1646  */
+    { add_option(RN_OPTION); }
+#line 2654 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 194:
+#line 457 "ptx.y" /* yacc.c:1646  */
+    { add_option(RZ_OPTION); }
+#line 2660 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 195:
+#line 458 "ptx.y" /* yacc.c:1646  */
+    { add_option(RM_OPTION); }
+#line 2666 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 196:
+#line 459 "ptx.y" /* yacc.c:1646  */
+    { add_option(RP_OPTION); }
+#line 2672 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 197:
+#line 462 "ptx.y" /* yacc.c:1646  */
+    { add_option(RNI_OPTION); }
+#line 2678 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 198:
+#line 463 "ptx.y" /* yacc.c:1646  */
+    { add_option(RZI_OPTION); }
+#line 2684 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 199:
+#line 464 "ptx.y" /* yacc.c:1646  */
+    { add_option(RMI_OPTION); }
+#line 2690 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 200:
+#line 465 "ptx.y" /* yacc.c:1646  */
+    { add_option(RPI_OPTION); }
+#line 2696 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 201:
+#line 468 "ptx.y" /* yacc.c:1646  */
+    { add_option(EQ_OPTION); }
+#line 2702 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 202:
+#line 469 "ptx.y" /* yacc.c:1646  */
+    { add_option(NE_OPTION); }
+#line 2708 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 203:
+#line 470 "ptx.y" /* yacc.c:1646  */
+    { add_option(LT_OPTION); }
+#line 2714 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 204:
+#line 471 "ptx.y" /* yacc.c:1646  */
+    { add_option(LE_OPTION); }
+#line 2720 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 205:
+#line 472 "ptx.y" /* yacc.c:1646  */
+    { add_option(GT_OPTION); }
+#line 2726 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 206:
+#line 473 "ptx.y" /* yacc.c:1646  */
+    { add_option(GE_OPTION); }
+#line 2732 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 207:
+#line 474 "ptx.y" /* yacc.c:1646  */
+    { add_option(LO_OPTION); }
+#line 2738 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 208:
+#line 475 "ptx.y" /* yacc.c:1646  */
+    { add_option(LS_OPTION); }
+#line 2744 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 209:
+#line 476 "ptx.y" /* yacc.c:1646  */
+    { add_option(HI_OPTION); }
+#line 2750 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 210:
+#line 477 "ptx.y" /* yacc.c:1646  */
+    { add_option(HS_OPTION); }
+#line 2756 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 211:
+#line 478 "ptx.y" /* yacc.c:1646  */
+    { add_option(EQU_OPTION); }
+#line 2762 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 212:
+#line 479 "ptx.y" /* yacc.c:1646  */
+    { add_option(NEU_OPTION); }
+#line 2768 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 213:
+#line 480 "ptx.y" /* yacc.c:1646  */
+    { add_option(LTU_OPTION); }
+#line 2774 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 214:
+#line 481 "ptx.y" /* yacc.c:1646  */
+    { add_option(LEU_OPTION); }
+#line 2780 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 215:
+#line 482 "ptx.y" /* yacc.c:1646  */
+    { add_option(GTU_OPTION); }
+#line 2786 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 216:
+#line 483 "ptx.y" /* yacc.c:1646  */
+    { add_option(GEU_OPTION); }
+#line 2792 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 217:
+#line 484 "ptx.y" /* yacc.c:1646  */
+    { add_option(NUM_OPTION); }
+#line 2798 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 218:
+#line 485 "ptx.y" /* yacc.c:1646  */
+    { add_option(NAN_OPTION); }
+#line 2804 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 221:
+#line 491 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_operand( (yyvsp[0].string_value) ); }
+#line 2810 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 222:
+#line 492 "ptx.y" /* yacc.c:1646  */
+    { add_neg_pred_operand( (yyvsp[0].string_value) ); }
+#line 2816 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 223:
+#line 493 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_operand( (yyvsp[0].string_value) ); change_operand_neg(); }
+#line 2822 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 228:
+#line 498 "ptx.y" /* yacc.c:1646  */
+    { change_operand_neg(); }
+#line 2828 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 230:
+#line 500 "ptx.y" /* yacc.c:1646  */
+    { add_address_operand((yyvsp[-2].string_value),(yyvsp[0].int_value)); }
+#line 2834 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 231:
+#line 501 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_operand( (yyvsp[-1].string_value) ); change_operand_lohi(1);}
+#line 2840 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 232:
+#line 502 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_operand( (yyvsp[-1].string_value) ); change_operand_lohi(1); change_operand_neg();}
+#line 2846 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 233:
+#line 503 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_operand( (yyvsp[-1].string_value) ); change_operand_lohi(2);}
+#line 2852 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 234:
+#line 504 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_operand( (yyvsp[-1].string_value) ); change_operand_lohi(2); change_operand_neg();}
+#line 2858 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 235:
+#line 505 "ptx.y" /* yacc.c:1646  */
+    { add_2vector_operand((yyvsp[-2].string_value),(yyvsp[0].string_value)); change_double_operand_type(-1);}
+#line 2864 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 236:
+#line 506 "ptx.y" /* yacc.c:1646  */
+    { add_2vector_operand((yyvsp[-3].string_value),(yyvsp[-1].string_value)); change_double_operand_type(-1); change_operand_lohi(1);}
+#line 2870 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 237:
+#line 507 "ptx.y" /* yacc.c:1646  */
+    { add_2vector_operand((yyvsp[-3].string_value),(yyvsp[-1].string_value)); change_double_operand_type(-1); change_operand_lohi(2);}
+#line 2876 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 238:
+#line 508 "ptx.y" /* yacc.c:1646  */
+    { add_2vector_operand((yyvsp[-2].string_value),(yyvsp[0].string_value)); change_double_operand_type(-3);}
+#line 2882 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 239:
+#line 509 "ptx.y" /* yacc.c:1646  */
+    { add_2vector_operand((yyvsp[-3].string_value),(yyvsp[-1].string_value)); change_double_operand_type(-3); change_operand_lohi(1);}
+#line 2888 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 240:
+#line 510 "ptx.y" /* yacc.c:1646  */
+    { add_2vector_operand((yyvsp[-3].string_value),(yyvsp[-1].string_value)); change_double_operand_type(-3); change_operand_lohi(2);}
+#line 2894 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 241:
+#line 513 "ptx.y" /* yacc.c:1646  */
+    { add_2vector_operand((yyvsp[-3].string_value),(yyvsp[-1].string_value)); }
+#line 2900 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 242:
+#line 514 "ptx.y" /* yacc.c:1646  */
+    { add_3vector_operand((yyvsp[-5].string_value),(yyvsp[-3].string_value),(yyvsp[-1].string_value)); }
+#line 2906 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 243:
+#line 515 "ptx.y" /* yacc.c:1646  */
+    { add_4vector_operand((yyvsp[-7].string_value),(yyvsp[-5].string_value),(yyvsp[-3].string_value),(yyvsp[-1].string_value)); }
+#line 2912 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 244:
+#line 516 "ptx.y" /* yacc.c:1646  */
+    { add_1vector_operand((yyvsp[-1].string_value)); }
+#line 2918 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 245:
+#line 519 "ptx.y" /* yacc.c:1646  */
+    { add_scalar_operand((yyvsp[-1].string_value)); }
+#line 2924 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 247:
+#line 524 "ptx.y" /* yacc.c:1646  */
+    { add_builtin_operand((yyvsp[-1].int_value),(yyvsp[0].int_value)); }
+#line 2930 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 248:
+#line 525 "ptx.y" /* yacc.c:1646  */
+    { add_builtin_operand((yyvsp[0].int_value),-1); }
+#line 2936 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 249:
+#line 528 "ptx.y" /* yacc.c:1646  */
+    { add_memory_operand(); }
+#line 2942 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 250:
+#line 529 "ptx.y" /* yacc.c:1646  */
+    { add_memory_operand(); change_memory_addr_space((yyvsp[-3].string_value)); }
+#line 2948 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 251:
+#line 530 "ptx.y" /* yacc.c:1646  */
+    { change_memory_addr_space((yyvsp[-3].string_value)); }
+#line 2954 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 252:
+#line 531 "ptx.y" /* yacc.c:1646  */
+    { change_memory_addr_space((yyvsp[-3].string_value)); add_memory_operand();}
+#line 2960 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 253:
+#line 532 "ptx.y" /* yacc.c:1646  */
+    { change_operand_neg(); }
+#line 2966 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 254:
+#line 535 "ptx.y" /* yacc.c:1646  */
+    { add_double_operand((yyvsp[-2].string_value),(yyvsp[0].string_value)); change_double_operand_type(1); }
+#line 2972 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 255:
+#line 536 "ptx.y" /* yacc.c:1646  */
+    { add_double_operand((yyvsp[-3].string_value),(yyvsp[-1].string_value)); change_double_operand_type(1); change_operand_lohi(1); }
+#line 2978 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 256:
+#line 537 "ptx.y" /* yacc.c:1646  */
+    { add_double_operand((yyvsp[-3].string_value),(yyvsp[-1].string_value)); change_double_operand_type(1); change_operand_lohi(2); }
+#line 2984 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 257:
+#line 538 "ptx.y" /* yacc.c:1646  */
+    { add_double_operand((yyvsp[-3].string_value),(yyvsp[0].string_value)); change_double_operand_type(2); }
+#line 2990 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 258:
+#line 539 "ptx.y" /* yacc.c:1646  */
+    { add_double_operand((yyvsp[-4].string_value),(yyvsp[-1].string_value)); change_double_operand_type(2); change_operand_lohi(1); }
+#line 2996 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 259:
+#line 540 "ptx.y" /* yacc.c:1646  */
+    { add_double_operand((yyvsp[-4].string_value),(yyvsp[-1].string_value)); change_double_operand_type(2); change_operand_lohi(2); }
+#line 3002 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 260:
+#line 541 "ptx.y" /* yacc.c:1646  */
+    { add_address_operand((yyvsp[-3].string_value),(yyvsp[0].int_value)); change_double_operand_type(3); }
+#line 3008 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 261:
+#line 544 "ptx.y" /* yacc.c:1646  */
+    { add_literal_int((yyvsp[0].int_value)); }
+#line 3014 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 262:
+#line 545 "ptx.y" /* yacc.c:1646  */
+    { add_literal_float((yyvsp[0].float_value)); }
+#line 3020 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 263:
+#line 546 "ptx.y" /* yacc.c:1646  */
+    { add_literal_double((yyvsp[0].double_value)); }
+#line 3026 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 264:
+#line 549 "ptx.y" /* yacc.c:1646  */
+    { add_address_operand((yyvsp[0].string_value),0); }
+#line 3032 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 265:
+#line 550 "ptx.y" /* yacc.c:1646  */
+    { add_address_operand((yyvsp[-1].string_value),0); change_operand_lohi(1);}
+#line 3038 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 266:
+#line 551 "ptx.y" /* yacc.c:1646  */
+    { add_address_operand((yyvsp[-1].string_value),0); change_operand_lohi(2); }
+#line 3044 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 267:
+#line 552 "ptx.y" /* yacc.c:1646  */
+    { add_address_operand((yyvsp[-2].string_value),(yyvsp[0].int_value)); }
+#line 3050 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 268:
+#line 553 "ptx.y" /* yacc.c:1646  */
+    { add_address_operand2((yyvsp[0].int_value)); }
+#line 3056 "ptx.tab.c" /* yacc.c:1646  */
+    break;
+
+
+#line 3060 "ptx.tab.c" /* yacc.c:1646  */
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now 'shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+         error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
+      else
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval);
+          yychar = YYEMPTY;
+        }
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+        {
+          yyn += YYTERROR;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+        YYABORT;
+
+
+      yydestruct ("Error: popping",
+                  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined yyoverflow || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  return yyresult;
+}
+#line 556 "ptx.y" /* yacc.c:1906  */
+
+
+extern int ptx_lineno;
+extern const char *g_filename;
+
+void syntax_not_implemented()
+{
+	printf("Parse error (%s:%u): this syntax is not (yet) implemented:\n",g_filename,ptx_lineno);
+	ptx_error(NULL);
+	abort();
+}
diff --git a/cuda-sim/ptx.tab.h b/cuda-sim/ptx.tab.h
new file mode 100644
--- /dev/null
+++ b/cuda-sim/ptx.tab.h
@@ -0,0 +1,227 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison interface for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+#ifndef YY_PTX_HOME_CUDA_SIM_PTX_TAB_H_INCLUDED
+# define YY_PTX_HOME_CUDA_SIM_PTX_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int ptx_debug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    STRING = 258,
+    OPCODE = 259,
+    ALIGN_DIRECTIVE = 260,
+    BRANCHTARGETS_DIRECTIVE = 261,
+    BYTE_DIRECTIVE = 262,
+    CALLPROTOTYPE_DIRECTIVE = 263,
+    CALLTARGETS_DIRECTIVE = 264,
+    CONST_DIRECTIVE = 265,
+    CONSTPTR_DIRECTIVE = 266,
+    PTR_DIRECTIVE = 267,
+    ENTRY_DIRECTIVE = 268,
+    EXTERN_DIRECTIVE = 269,
+    FILE_DIRECTIVE = 270,
+    FUNC_DIRECTIVE = 271,
+    GLOBAL_DIRECTIVE = 272,
+    LOCAL_DIRECTIVE = 273,
+    LOC_DIRECTIVE = 274,
+    MAXNCTAPERSM_DIRECTIVE = 275,
+    MAXNNREG_DIRECTIVE = 276,
+    MAXNTID_DIRECTIVE = 277,
+    MINNCTAPERSM_DIRECTIVE = 278,
+    PARAM_DIRECTIVE = 279,
+    PRAGMA_DIRECTIVE = 280,
+    REG_DIRECTIVE = 281,
+    REQNTID_DIRECTIVE = 282,
+    SECTION_DIRECTIVE = 283,
+    SHARED_DIRECTIVE = 284,
+    SREG_DIRECTIVE = 285,
+    STRUCT_DIRECTIVE = 286,
+    SURF_DIRECTIVE = 287,
+    TARGET_DIRECTIVE = 288,
+    TEX_DIRECTIVE = 289,
+    UNION_DIRECTIVE = 290,
+    VERSION_DIRECTIVE = 291,
+    ADDRESS_SIZE_DIRECTIVE = 292,
+    VISIBLE_DIRECTIVE = 293,
+    IDENTIFIER = 294,
+    INT_OPERAND = 295,
+    FLOAT_OPERAND = 296,
+    DOUBLE_OPERAND = 297,
+    S8_TYPE = 298,
+    S16_TYPE = 299,
+    S32_TYPE = 300,
+    S64_TYPE = 301,
+    U8_TYPE = 302,
+    U16_TYPE = 303,
+    U32_TYPE = 304,
+    U64_TYPE = 305,
+    F16_TYPE = 306,
+    F32_TYPE = 307,
+    F64_TYPE = 308,
+    FF64_TYPE = 309,
+    B8_TYPE = 310,
+    B16_TYPE = 311,
+    B32_TYPE = 312,
+    B64_TYPE = 313,
+    BB64_TYPE = 314,
+    BB128_TYPE = 315,
+    PRED_TYPE = 316,
+    TEXREF_TYPE = 317,
+    SAMPLERREF_TYPE = 318,
+    SURFREF_TYPE = 319,
+    V2_TYPE = 320,
+    V3_TYPE = 321,
+    V4_TYPE = 322,
+    COMMA = 323,
+    PRED = 324,
+    HALF_OPTION = 325,
+    EQ_OPTION = 326,
+    NE_OPTION = 327,
+    LT_OPTION = 328,
+    LE_OPTION = 329,
+    GT_OPTION = 330,
+    GE_OPTION = 331,
+    LO_OPTION = 332,
+    LS_OPTION = 333,
+    HI_OPTION = 334,
+    HS_OPTION = 335,
+    EQU_OPTION = 336,
+    NEU_OPTION = 337,
+    LTU_OPTION = 338,
+    LEU_OPTION = 339,
+    GTU_OPTION = 340,
+    GEU_OPTION = 341,
+    NUM_OPTION = 342,
+    NAN_OPTION = 343,
+    CF_OPTION = 344,
+    SF_OPTION = 345,
+    NSF_OPTION = 346,
+    LEFT_SQUARE_BRACKET = 347,
+    RIGHT_SQUARE_BRACKET = 348,
+    WIDE_OPTION = 349,
+    SPECIAL_REGISTER = 350,
+    MINUS = 351,
+    PLUS = 352,
+    COLON = 353,
+    SEMI_COLON = 354,
+    EXCLAMATION = 355,
+    PIPE = 356,
+    RIGHT_BRACE = 357,
+    LEFT_BRACE = 358,
+    EQUALS = 359,
+    PERIOD = 360,
+    BACKSLASH = 361,
+    DIMENSION_MODIFIER = 362,
+    RN_OPTION = 363,
+    RZ_OPTION = 364,
+    RM_OPTION = 365,
+    RP_OPTION = 366,
+    RNI_OPTION = 367,
+    RZI_OPTION = 368,
+    RMI_OPTION = 369,
+    RPI_OPTION = 370,
+    UNI_OPTION = 371,
+    GEOM_MODIFIER_1D = 372,
+    GEOM_MODIFIER_2D = 373,
+    GEOM_MODIFIER_3D = 374,
+    SAT_OPTION = 375,
+    FTZ_OPTION = 376,
+    NEG_OPTION = 377,
+    ATOMIC_AND = 378,
+    ATOMIC_OR = 379,
+    ATOMIC_XOR = 380,
+    ATOMIC_CAS = 381,
+    ATOMIC_EXCH = 382,
+    ATOMIC_ADD = 383,
+    ATOMIC_INC = 384,
+    ATOMIC_DEC = 385,
+    ATOMIC_MIN = 386,
+    ATOMIC_MAX = 387,
+    LEFT_ANGLE_BRACKET = 388,
+    RIGHT_ANGLE_BRACKET = 389,
+    LEFT_PAREN = 390,
+    RIGHT_PAREN = 391,
+    APPROX_OPTION = 392,
+    FULL_OPTION = 393,
+    ANY_OPTION = 394,
+    ALL_OPTION = 395,
+    BALLOT_OPTION = 396,
+    GLOBAL_OPTION = 397,
+    CTA_OPTION = 398,
+    SYS_OPTION = 399,
+    EXIT_OPTION = 400,
+    ABS_OPTION = 401,
+    TO_OPTION = 402,
+    CA_OPTION = 403,
+    CG_OPTION = 404,
+    CS_OPTION = 405,
+    LU_OPTION = 406,
+    CV_OPTION = 407,
+    WB_OPTION = 408,
+    WT_OPTION = 409
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 30 "ptx.y" /* yacc.c:1909  */
+
+  double double_value;
+  float  float_value;
+  int    int_value;
+  char * string_value;
+  void * ptr_value;
+
+#line 217 "ptx.tab.h" /* yacc.c:1909  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE ptx_lval;
+
+int ptx_parse (void);
+
+#endif /* !YY_PTX_HOME_CUDA_SIM_PTX_TAB_H_INCLUDED  */
diff --git a/cuda-sim/ptx_parser_decode.def b/cuda-sim/ptx_parser_decode.def
new file mode 100644
--- /dev/null
+++ b/cuda-sim/ptx_parser_decode.def
@@ -0,0 +1,152 @@
+DEF(STRING,"STRING")
+DEF(OPCODE,"OPCODE")
+DEF(ALIGN_DIRECTIVE,"ALIGN_DIRECTIVE")
+DEF(BRANCHTARGETS_DIRECTIVE,"BRANCHTARGETS_DIRECTIVE")
+DEF(BYTE_DIRECTIVE,"BYTE_DIRECTIVE")
+DEF(CALLPROTOTYPE_DIRECTIVE,"CALLPROTOTYPE_DIRECTIVE")
+DEF(CALLTARGETS_DIRECTIVE,"CALLTARGETS_DIRECTIVE")
+DEF(CONST_DIRECTIVE,"CONST_DIRECTIVE")
+DEF(CONSTPTR_DIRECTIVE,"CONSTPTR_DIRECTIVE")
+DEF(PTR_DIRECTIVE,"PTR_DIRECTIVE")
+DEF(ENTRY_DIRECTIVE,"ENTRY_DIRECTIVE")
+DEF(EXTERN_DIRECTIVE,"EXTERN_DIRECTIVE")
+DEF(FILE_DIRECTIVE,"FILE_DIRECTIVE")
+DEF(FUNC_DIRECTIVE,"FUNC_DIRECTIVE")
+DEF(GLOBAL_DIRECTIVE,"GLOBAL_DIRECTIVE")
+DEF(LOCAL_DIRECTIVE,"LOCAL_DIRECTIVE")
+DEF(LOC_DIRECTIVE,"LOC_DIRECTIVE")
+DEF(MAXNCTAPERSM_DIRECTIVE,"MAXNCTAPERSM_DIRECTIVE")
+DEF(MAXNNREG_DIRECTIVE,"MAXNNREG_DIRECTIVE")
+DEF(MAXNTID_DIRECTIVE,"MAXNTID_DIRECTIVE")
+DEF(MINNCTAPERSM_DIRECTIVE,"MINNCTAPERSM_DIRECTIVE")
+DEF(PARAM_DIRECTIVE,"PARAM_DIRECTIVE")
+DEF(PRAGMA_DIRECTIVE,"PRAGMA_DIRECTIVE")
+DEF(REG_DIRECTIVE,"REG_DIRECTIVE")
+DEF(REQNTID_DIRECTIVE,"REQNTID_DIRECTIVE")
+DEF(SECTION_DIRECTIVE,"SECTION_DIRECTIVE")
+DEF(SHARED_DIRECTIVE,"SHARED_DIRECTIVE")
+DEF(SREG_DIRECTIVE,"SREG_DIRECTIVE")
+DEF(STRUCT_DIRECTIVE,"STRUCT_DIRECTIVE")
+DEF(SURF_DIRECTIVE,"SURF_DIRECTIVE")
+DEF(TARGET_DIRECTIVE,"TARGET_DIRECTIVE")
+DEF(TEX_DIRECTIVE,"TEX_DIRECTIVE")
+DEF(UNION_DIRECTIVE,"UNION_DIRECTIVE")
+DEF(VERSION_DIRECTIVE,"VERSION_DIRECTIVE")
+DEF(ADDRESS_SIZE_DIRECTIVE,"ADDRESS_SIZE_DIRECTIVE")
+DEF(VISIBLE_DIRECTIVE,"VISIBLE_DIRECTIVE")
+DEF(IDENTIFIER,"IDENTIFIER")
+DEF(INT_OPERAND,"INT_OPERAND")
+DEF(FLOAT_OPERAND,"FLOAT_OPERAND")
+DEF(DOUBLE_OPERAND,"DOUBLE_OPERAND")
+DEF(S8_TYPE,"S8_TYPE")
+DEF(S16_TYPE,"S16_TYPE")
+DEF(S32_TYPE,"S32_TYPE")
+DEF(S64_TYPE,"S64_TYPE")
+DEF(U8_TYPE,"U8_TYPE")
+DEF(U16_TYPE,"U16_TYPE")
+DEF(U32_TYPE,"U32_TYPE")
+DEF(U64_TYPE,"U64_TYPE")
+DEF(F16_TYPE,"F16_TYPE")
+DEF(F32_TYPE,"F32_TYPE")
+DEF(F64_TYPE,"F64_TYPE")
+DEF(FF64_TYPE,"FF64_TYPE")
+DEF(B8_TYPE,"B8_TYPE")
+DEF(B16_TYPE,"B16_TYPE")
+DEF(B32_TYPE,"B32_TYPE")
+DEF(B64_TYPE,"B64_TYPE")
+DEF(BB64_TYPE,"BB64_TYPE")
+DEF(BB128_TYPE,"BB128_TYPE")
+DEF(PRED_TYPE,"PRED_TYPE")
+DEF(TEXREF_TYPE,"TEXREF_TYPE")
+DEF(SAMPLERREF_TYPE,"SAMPLERREF_TYPE")
+DEF(SURFREF_TYPE,"SURFREF_TYPE")
+DEF(V2_TYPE,"V2_TYPE")
+DEF(V3_TYPE,"V3_TYPE")
+DEF(V4_TYPE,"V4_TYPE")
+DEF(COMMA,"COMMA")
+DEF(PRED,"PRED")
+DEF(HALF_OPTION,"HALF_OPTION")
+DEF(EQ_OPTION,"EQ_OPTION")
+DEF(NE_OPTION,"NE_OPTION")
+DEF(LT_OPTION,"LT_OPTION")
+DEF(LE_OPTION,"LE_OPTION")
+DEF(GT_OPTION,"GT_OPTION")
+DEF(GE_OPTION,"GE_OPTION")
+DEF(LO_OPTION,"LO_OPTION")
+DEF(LS_OPTION,"LS_OPTION")
+DEF(HI_OPTION,"HI_OPTION")
+DEF(HS_OPTION,"HS_OPTION")
+DEF(EQU_OPTION,"EQU_OPTION")
+DEF(NEU_OPTION,"NEU_OPTION")
+DEF(LTU_OPTION,"LTU_OPTION")
+DEF(LEU_OPTION,"LEU_OPTION")
+DEF(GTU_OPTION,"GTU_OPTION")
+DEF(GEU_OPTION,"GEU_OPTION")
+DEF(NUM_OPTION,"NUM_OPTION")
+DEF(NAN_OPTION,"NAN_OPTION")
+DEF(CF_OPTION,"CF_OPTION")
+DEF(SF_OPTION,"SF_OPTION")
+DEF(NSF_OPTION,"NSF_OPTION")
+DEF(LEFT_SQUARE_BRACKET,"LEFT_SQUARE_BRACKET")
+DEF(RIGHT_SQUARE_BRACKET,"RIGHT_SQUARE_BRACKET")
+DEF(WIDE_OPTION,"WIDE_OPTION")
+DEF(SPECIAL_REGISTER,"SPECIAL_REGISTER")
+DEF(MINUS,"MINUS")
+DEF(PLUS,"PLUS")
+DEF(COLON,"COLON")
+DEF(SEMI_COLON,"SEMI_COLON")
+DEF(EXCLAMATION,"EXCLAMATION")
+DEF(PIPE,"PIPE")
+DEF(RIGHT_BRACE,"RIGHT_BRACE")
+DEF(LEFT_BRACE,"LEFT_BRACE")
+DEF(EQUALS,"EQUALS")
+DEF(PERIOD,"PERIOD")
+DEF(BACKSLASH,"BACKSLASH")
+DEF(DIMENSION_MODIFIER,"DIMENSION_MODIFIER")
+DEF(RN_OPTION,"RN_OPTION")
+DEF(RZ_OPTION,"RZ_OPTION")
+DEF(RM_OPTION,"RM_OPTION")
+DEF(RP_OPTION,"RP_OPTION")
+DEF(RNI_OPTION,"RNI_OPTION")
+DEF(RZI_OPTION,"RZI_OPTION")
+DEF(RMI_OPTION,"RMI_OPTION")
+DEF(RPI_OPTION,"RPI_OPTION")
+DEF(UNI_OPTION,"UNI_OPTION")
+DEF(GEOM_MODIFIER_1D,"GEOM_MODIFIER_1D")
+DEF(GEOM_MODIFIER_2D,"GEOM_MODIFIER_2D")
+DEF(GEOM_MODIFIER_3D,"GEOM_MODIFIER_3D")
+DEF(SAT_OPTION,"SAT_OPTION")
+DEF(FTZ_OPTION,"FTZ_OPTION")
+DEF(NEG_OPTION,"NEG_OPTION")
+DEF(ATOMIC_AND,"ATOMIC_AND")
+DEF(ATOMIC_OR,"ATOMIC_OR")
+DEF(ATOMIC_XOR,"ATOMIC_XOR")
+DEF(ATOMIC_CAS,"ATOMIC_CAS")
+DEF(ATOMIC_EXCH,"ATOMIC_EXCH")
+DEF(ATOMIC_ADD,"ATOMIC_ADD")
+DEF(ATOMIC_INC,"ATOMIC_INC")
+DEF(ATOMIC_DEC,"ATOMIC_DEC")
+DEF(ATOMIC_MIN,"ATOMIC_MIN")
+DEF(ATOMIC_MAX,"ATOMIC_MAX")
+DEF(LEFT_ANGLE_BRACKET,"LEFT_ANGLE_BRACKET")
+DEF(RIGHT_ANGLE_BRACKET,"RIGHT_ANGLE_BRACKET")
+DEF(LEFT_PAREN,"LEFT_PAREN")
+DEF(RIGHT_PAREN,"RIGHT_PAREN")
+DEF(APPROX_OPTION,"APPROX_OPTION")
+DEF(FULL_OPTION,"FULL_OPTION")
+DEF(ANY_OPTION,"ANY_OPTION")
+DEF(ALL_OPTION,"ALL_OPTION")
+DEF(BALLOT_OPTION,"BALLOT_OPTION")
+DEF(GLOBAL_OPTION,"GLOBAL_OPTION")
+DEF(CTA_OPTION,"CTA_OPTION")
+DEF(SYS_OPTION,"SYS_OPTION")
+DEF(EXIT_OPTION,"EXIT_OPTION")
+DEF(ABS_OPTION,"ABS_OPTION")
+DEF(TO_OPTION,"TO_OPTION")
+DEF(CA_OPTION,"CA_OPTION")
+DEF(CG_OPTION,"CG_OPTION")
+DEF(CS_OPTION,"CS_OPTION")
+DEF(LU_OPTION,"LU_OPTION")
+DEF(CV_OPTION,"CV_OPTION")
+DEF(WB_OPTION,"WB_OPTION")
+DEF(WT_OPTION,"WT_OPTION")
diff --git a/cuda-sim/ptxinfo.tab.c b/cuda-sim/ptxinfo.tab.c
new file mode 100644
--- /dev/null
+++ b/cuda-sim/ptxinfo.tab.c
@@ -0,0 +1,1578 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison implementation for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "3.0.2"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+
+/* Substitute the variable and function names.  */
+#define yyparse         ptxinfo_parse
+#define yylex           ptxinfo_lex
+#define yyerror         ptxinfo_error
+#define yydebug         ptxinfo_debug
+#define yynerrs         ptxinfo_nerrs
+
+#define yylval          ptxinfo_lval
+#define yychar          ptxinfo_char
+
+/* Copy the first part of user declarations.  */
+
+#line 75 "ptxinfo.tab.c" /* yacc.c:339  */
+
+# ifndef YY_NULLPTR
+#  if defined __cplusplus && 201103L <= __cplusplus
+#   define YY_NULLPTR nullptr
+#  else
+#   define YY_NULLPTR 0
+#  endif
+# endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* In a future release of Bison, this section will be replaced
+   by #include "ptxinfo.tab.h".  */
+#ifndef YY_PTXINFO_CUDA_SIM_PTXINFO_TAB_H_INCLUDED
+# define YY_PTXINFO_CUDA_SIM_PTXINFO_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int ptxinfo_debug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    INT_OPERAND = 258,
+    HEADER = 259,
+    INFO = 260,
+    FUNC = 261,
+    USED = 262,
+    REGS = 263,
+    BYTES = 264,
+    LMEM = 265,
+    SMEM = 266,
+    CMEM = 267,
+    IDENTIFIER = 268,
+    PLUS = 269,
+    COMMA = 270,
+    LEFT_SQUARE_BRACKET = 271,
+    RIGHT_SQUARE_BRACKET = 272,
+    COLON = 273,
+    SEMICOLON = 274,
+    QUOTE = 275,
+    LINE = 276,
+    WARNING = 277,
+    FOR = 278
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 30 "ptxinfo.y" /* yacc.c:355  */
+
+  int    int_value;
+  char * string_value;
+
+#line 144 "ptxinfo.tab.c" /* yacc.c:355  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE ptxinfo_lval;
+
+int ptxinfo_parse (void);
+
+#endif /* !YY_PTXINFO_CUDA_SIM_PTXINFO_TAB_H_INCLUDED  */
+
+/* Copy the second part of user declarations.  */
+#line 57 "ptxinfo.y" /* yacc.c:358  */
+
+	#include <stdlib.h>
+	#include <string.h>
+
+	static unsigned g_declared;
+	static unsigned g_system;
+	int ptxinfo_lex(void);
+	void ptxinfo_addinfo();
+	void ptxinfo_function(const char *fname );
+	void ptxinfo_regs( unsigned nregs );
+	void ptxinfo_lmem( unsigned declared, unsigned system );
+	void ptxinfo_smem( unsigned declared, unsigned system );
+	void ptxinfo_cmem( unsigned nbytes, unsigned bank );
+	int ptxinfo_error(const char*);
+
+#line 174 "ptxinfo.tab.c" /* yacc.c:358  */
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#else
+typedef signed char yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE
+# if (defined __GNUC__                                               \
+      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
+     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
+#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
+# else
+#  define YY_ATTRIBUTE(Spec) /* empty */
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE_PURE
+# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+#endif
+
+#ifndef YY_ATTRIBUTE_UNUSED
+# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
+#endif
+
+#if !defined _Noreturn \
+     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
+# if defined _MSC_VER && 1200 <= _MSC_VER
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(E) ((void) (E))
+#else
+# define YYUSE(E) /* empty */
+#endif
+
+#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define YY_INITIAL_VALUE(Value) Value
+#endif
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYSIZE_T yynewbytes;                                            \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / sizeof (*yyptr);                          \
+      }                                                                 \
+    while (0)
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYSIZE_T yyi;                         \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (0)
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  2
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   46
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  24
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  8
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  21
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  46
+
+/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
+   by yylex, with out-of-bounds checking.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   278
+
+#define YYTRANSLATE(YYX)                                                \
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, without out-of-bounds checking.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23
+};
+
+#if YYDEBUG
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_uint8 yyrline[] =
+{
+       0,    75,    75,    76,    79,    80,    81,    84,    85,    88,
+      89,    91,    92,    95,    96,    97,    98,    99,   100,   101,
+     102,   105
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || 0
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "INT_OPERAND", "HEADER", "INFO", "FUNC",
+  "USED", "REGS", "BYTES", "LMEM", "SMEM", "CMEM", "IDENTIFIER", "PLUS",
+  "COMMA", "LEFT_SQUARE_BRACKET", "RIGHT_SQUARE_BRACKET", "COLON",
+  "SEMICOLON", "QUOTE", "LINE", "WARNING", "FOR", "$accept", "input",
+  "line", "line_info", "function_name", "function_info", "info", "tuple", YY_NULLPTR
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[NUM] -- (External) token number corresponding to the
+   (internal) symbol number NUM (which must be that of a token).  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278
+};
+# endif
+
+#define YYPACT_NINF -16
+
+#define yypact_value_is_default(Yystate) \
+  (!!((Yystate) == (-16)))
+
+#define YYTABLE_NINF -1
+
+#define yytable_value_is_error(Yytable_value) \
+  0
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+static const yytype_int8 yypact[] =
+{
+     -16,    11,   -16,    -5,   -16,   -15,    -2,   -16,     3,     0,
+      -7,     2,    20,   -16,   -16,    -1,   -16,    -6,    21,   -16,
+       8,    22,    13,    19,     9,   -16,   -16,    10,   -16,   -16,
+      12,    23,    14,   -16,   -16,    15,    27,   -16,    16,   -16,
+      18,    24,   -16,    25,    26,   -16
+};
+
+  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+     Performed when YYTABLE does not specify something else to do.  Zero
+     means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       2,     0,     1,     0,     3,     0,     0,     6,     0,     0,
+       0,     0,     0,     4,     7,     8,    11,     0,     0,    20,
+       0,     0,     0,     0,     0,    14,    15,     0,    17,    18,
+      19,     0,     0,    13,    12,     0,     0,    21,     9,     5,
+       0,     0,    16,     0,     0,    10
+};
+
+  /* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -16,   -16,   -16,   -16,   -16,   -16,     7,   -16
+};
+
+  /* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     1,     4,    13,    14,    15,    16,    17
+};
+
+  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule whose
+     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_uint8 yytable[] =
+{
+       5,    19,    20,     8,    25,    26,    10,    21,     6,    11,
+      12,     2,    10,     9,    24,     3,    12,     7,    28,    29,
+      30,    18,    22,    23,    27,    31,    32,    33,    36,    35,
+      40,    34,    37,     0,    38,    42,     0,    39,    44,    41,
+       0,     0,     0,     0,    43,     0,    45
+};
+
+static const yytype_int8 yycheck[] =
+{
+       5,     8,     9,    18,    10,    11,     3,    14,    13,     6,
+       7,     0,     3,    15,    15,     4,     7,    22,    10,    11,
+      12,    21,    20,     3,     3,     3,    13,     8,    16,    19,
+       3,    24,     9,    -1,    20,    17,    -1,    22,    13,    23,
+      -1,    -1,    -1,    -1,    20,    -1,    20
+};
+
+  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    25,     0,     4,    26,     5,    13,    22,    18,    15,
+       3,     6,     7,    27,    28,    29,    30,    31,    21,     8,
+       9,    14,    20,     3,    15,    10,    11,     3,    10,    11,
+      12,     3,    13,     8,    30,    19,    16,     9,    20,    22,
+       3,    23,    17,    20,    13,    20
+};
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    24,    25,    25,    26,    26,    26,    27,    27,    28,
+      28,    29,    29,    30,    30,    30,    30,    30,    30,    30,
+      30,    31
+};
+
+  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     2,     4,     7,     2,     1,     1,     4,
+       8,     1,     3,     3,     2,     2,     6,     3,     3,     3,
+       2,     4
+};
+
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+#define YYEMPTY         (-2)
+#define YYEOF           0
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                  \
+do                                                              \
+  if (yychar == YYEMPTY)                                        \
+    {                                                           \
+      yychar = (Token);                                         \
+      yylval = (Value);                                         \
+      YYPOPSTACK (yylen);                                       \
+      yystate = *yyssp;                                         \
+      goto yybackup;                                            \
+    }                                                           \
+  else                                                          \
+    {                                                           \
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;                                                  \
+    }                                                           \
+while (0)
+
+/* Error token number */
+#define YYTERROR        1
+#define YYERRCODE       256
+
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
+
+/* This macro is provided for backward compatibility. */
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Type, Value); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+
+/*----------------------------------------.
+| Print this symbol's value on YYOUTPUT.  |
+`----------------------------------------*/
+
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  FILE *yyo = yyoutput;
+  YYUSE (yyo);
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  YYUSE (yytype);
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  YYFPRINTF (yyoutput, "%s %s (",
+             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+static void
+yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
+{
+  unsigned long int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+             yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       yystos[yyssp[yyi + 1 - yynrhs]],
+                       &(yyvsp[(yyi + 1) - (yynrhs)])
+                                              );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, Rule); \
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+yystrlen (const char *yystr)
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            /* Fall through.  */
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULLPTR;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                {
+                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
+                  if (! (yysize <= yysize1
+                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                    return 2;
+                  yysize = yysize1;
+                }
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  {
+    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
+    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+      return 2;
+    yysize = yysize1;
+  }
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+{
+  YYUSE (yyvaluep);
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
+
+
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+int
+yyparse (void)
+{
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       'yyss': related to states.
+       'yyvs': related to semantic values.
+
+       Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yyssp = yyss = yyssa;
+  yyvsp = yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        YYSTYPE *yyvs1 = yyvs;
+        yytype_int16 *yyss1 = yyss;
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * sizeof (*yyssp),
+                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yystacksize);
+
+        yyss = yyss1;
+        yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+        goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
+
+      {
+        yytype_int16 *yyss1 = yyss;
+        union yyalloc *yyptr =
+          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+        if (! yyptr)
+          goto yyexhaustedlab;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+                  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = yylex ();
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     '$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 6:
+#line 81 "ptxinfo.y" /* yacc.c:1646  */
+    { printf("GPGPU-Sim: ptxas %s\n", (yyvsp[0].string_value)); }
+#line 1272 "ptxinfo.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 8:
+#line 85 "ptxinfo.y" /* yacc.c:1646  */
+    { ptxinfo_addinfo(); }
+#line 1278 "ptxinfo.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 9:
+#line 88 "ptxinfo.y" /* yacc.c:1646  */
+    { ptxinfo_function((yyvsp[-1].string_value)); }
+#line 1284 "ptxinfo.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 10:
+#line 89 "ptxinfo.y" /* yacc.c:1646  */
+    { ptxinfo_function((yyvsp[-5].string_value)); }
+#line 1290 "ptxinfo.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 13:
+#line 95 "ptxinfo.y" /* yacc.c:1646  */
+    { ptxinfo_regs((yyvsp[-1].int_value)); }
+#line 1296 "ptxinfo.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 14:
+#line 96 "ptxinfo.y" /* yacc.c:1646  */
+    { ptxinfo_lmem(g_declared,g_system); }
+#line 1302 "ptxinfo.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 15:
+#line 97 "ptxinfo.y" /* yacc.c:1646  */
+    { ptxinfo_smem(g_declared,g_system); }
+#line 1308 "ptxinfo.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 16:
+#line 98 "ptxinfo.y" /* yacc.c:1646  */
+    { ptxinfo_cmem((yyvsp[-5].int_value),(yyvsp[-1].int_value)); }
+#line 1314 "ptxinfo.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 17:
+#line 99 "ptxinfo.y" /* yacc.c:1646  */
+    { ptxinfo_lmem((yyvsp[-2].int_value),0); }
+#line 1320 "ptxinfo.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 18:
+#line 100 "ptxinfo.y" /* yacc.c:1646  */
+    { ptxinfo_smem((yyvsp[-2].int_value),0); }
+#line 1326 "ptxinfo.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 19:
+#line 101 "ptxinfo.y" /* yacc.c:1646  */
+    { ptxinfo_cmem((yyvsp[-2].int_value),0); }
+#line 1332 "ptxinfo.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 20:
+#line 102 "ptxinfo.y" /* yacc.c:1646  */
+    { ptxinfo_regs((yyvsp[-1].int_value)); }
+#line 1338 "ptxinfo.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 21:
+#line 105 "ptxinfo.y" /* yacc.c:1646  */
+    { g_declared=(yyvsp[-3].int_value); g_system=(yyvsp[-1].int_value); }
+#line 1344 "ptxinfo.tab.c" /* yacc.c:1646  */
+    break;
+
+
+#line 1348 "ptxinfo.tab.c" /* yacc.c:1646  */
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now 'shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+         error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
+      else
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval);
+          yychar = YYEMPTY;
+        }
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+        {
+          yyn += YYTERROR;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+        YYABORT;
+
+
+      yydestruct ("Error: popping",
+                  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined yyoverflow || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  return yyresult;
+}
+#line 107 "ptxinfo.y" /* yacc.c:1906  */
+
+
+
diff --git a/cuda-sim/ptxinfo.tab.h b/cuda-sim/ptxinfo.tab.h
new file mode 100644
--- /dev/null
+++ b/cuda-sim/ptxinfo.tab.h
@@ -0,0 +1,93 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison interface for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+#ifndef YY_PTXINFO_CUDA_SIM_PTXINFO_TAB_H_INCLUDED
+# define YY_PTXINFO_CUDA_SIM_PTXINFO_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int ptxinfo_debug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    INT_OPERAND = 258,
+    HEADER = 259,
+    INFO = 260,
+    FUNC = 261,
+    USED = 262,
+    REGS = 263,
+    BYTES = 264,
+    LMEM = 265,
+    SMEM = 266,
+    CMEM = 267,
+    IDENTIFIER = 268,
+    PLUS = 269,
+    COMMA = 270,
+    LEFT_SQUARE_BRACKET = 271,
+    RIGHT_SQUARE_BRACKET = 272,
+    COLON = 273,
+    SEMICOLON = 274,
+    QUOTE = 275,
+    LINE = 276,
+    WARNING = 277,
+    FOR = 278
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 30 "ptxinfo.y" /* yacc.c:1909  */
+
+  int    int_value;
+  char * string_value;
+
+#line 83 "ptxinfo.tab.h" /* yacc.c:1909  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE ptxinfo_lval;
+
+int ptxinfo_parse (void);
+
+#endif /* !YY_PTXINFO_CUDA_SIM_PTXINFO_TAB_H_INCLUDED  */
diff --git a/intersim2/lex.yy.c b/intersim2/lex.yy.c
new file mode 100644
--- /dev/null
+++ b/intersim2/lex.yy.c
@@ -0,0 +1,1836 @@
+
+#line 3 "lex.yy.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 10
+#define YY_END_OF_BUFFER 11
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[36] =
+    {   0,
+        2,    2,   11,    9,    2,    3,    8,    8,    8,    5,
+        8,    9,    2,    8,    8,    5,    6,    1,    0,    5,
+        0,    0,    8,    1,    1,    6,    0,    7,    0,    4,
+        8,    7,    0,    4,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    1,    1,    1,    1,    1,    1,    4,
+        4,    1,    5,    6,    7,    8,    9,   10,   10,   10,
+       10,   10,   10,   10,   10,   10,   10,    1,    1,    1,
+        1,    1,    1,    1,   11,   11,   11,   11,   12,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+        1,    1,    1,    1,   11,    1,   11,   11,   11,   11,
+
+       12,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   13,    1,   14,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[15] =
+    {   0,
+        1,    1,    2,    3,    4,    3,    5,    3,    6,    5,
+        3,    3,    3,    3
+    } ;
+
+static yyconst flex_int16_t yy_base[42] =
+    {   0,
+        0,    0,   70,   71,   67,   71,    7,   58,   58,   10,
+        0,    0,   64,    0,   55,   15,    9,   27,   54,    0,
+       53,   10,   25,    0,   32,   26,   51,   45,   33,    0,
+       34,   27,   17,   12,   71,   36,   40,   45,   48,   53,
+       57
+    } ;
+
+static yyconst flex_int16_t yy_def[42] =
+    {   0,
+       35,    1,   35,   35,   35,   35,   36,   36,   36,   35,
+       36,   37,   35,   36,   36,   36,   36,   38,   35,   10,
+       39,   37,   36,   40,   38,   35,   35,   35,   41,   22,
+       36,   36,   41,   41,    0,   35,   35,   35,   35,   35,
+       35
+    } ;
+
+static yyconst flex_int16_t yy_nxt[86] =
+    {   0,
+        4,    5,    6,    4,    4,    4,    7,    8,    9,   10,
+       11,   11,   12,    4,   15,   29,   16,   19,   17,   20,
+       23,   21,   15,   30,   16,   34,   23,   24,   24,   31,
+       34,   31,   24,   24,   32,   26,   32,   21,   14,   14,
+       14,   14,   22,   32,   22,   25,   34,   25,   25,   25,
+       25,   27,   27,   24,   28,   24,   24,   24,   24,   33,
+       28,   33,   28,   26,   17,   13,   18,   17,   13,   35,
+        3,   35,   35,   35,   35,   35,   35,   35,   35,   35,
+       35,   35,   35,   35,   35
+    } ;
+
+static yyconst flex_int16_t yy_chk[86] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    7,   22,    7,   10,   17,   10,
+       17,   10,   16,   22,   16,   34,   16,   18,   18,   23,
+       33,   23,   25,   25,   23,   26,   32,   26,   36,   36,
+       36,   36,   37,   31,   37,   38,   29,   38,   38,   38,
+       38,   39,   39,   40,   28,   40,   40,   40,   40,   41,
+       27,   41,   21,   19,   15,   13,    9,    8,    5,    3,
+       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
+       35,   35,   35,   35,   35
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "config.l"
+#line 2 "config.l"
+
+#include "y.tab.h"
+
+static unsigned int lineno = 1;
+
+void config_error(char * msg, int lineno);
+void yyerror(char * msg);
+
+extern int config_input(char *, int);
+#undef YY_INPUT
+#define YY_INPUT(b, r, ms) (r = config_input(b, ms))
+
+#line 499 "lex.yy.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 21 "config.l"
+
+
+   /* Ignore comments and all spaces */
+
+#line 691 "lex.yy.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 36 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 71 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 25 "config.l"
+;
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 26 "config.l"
+;
+	YY_BREAK
+case 3:
+/* rule 3 can match eol */
+YY_RULE_SETUP
+#line 28 "config.l"
+{ lineno++; }
+	YY_BREAK
+/* Commands */
+case 4:
+YY_RULE_SETUP
+#line 32 "config.l"
+{ yylval.name = strdup( yytext ); return STR; }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 34 "config.l"
+{ yylval.num = atoi( yytext ); return NUM; }
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 36 "config.l"
+{ yylval.fnum = atof( yytext ); return FNUM; }
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 38 "config.l"
+{ yylval.fnum = atof( yytext ); return FNUM;}
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 40 "config.l"
+{ yylval.name = strdup( yytext ); return STR; }
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 42 "config.l"
+{ return yytext[0]; }
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 44 "config.l"
+ECHO;
+	YY_BREAK
+#line 826 "lex.yy.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 36 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 36 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 35);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 44 "config.l"
+
+
+
+void yyerror( char * msg )
+{
+  config_error( msg, lineno );
+}
+
+int yywrap()
+{
+  return 1;
+}
+
diff --git a/intersim2/y.tab.c b/intersim2/y.tab.c
new file mode 100644
--- /dev/null
+++ b/intersim2/y.tab.c
@@ -0,0 +1,1467 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison implementation for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "3.0.2"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 1 "config.y" /* yacc.c:339  */
+
+
+int  yylex(void);
+void yyerror(char * msg);
+void config_assign_string( char const * field, char const * value );
+void config_assign_int( char const * field, int value );
+void config_assign_float( char const * field, double value );
+
+#ifdef _WIN32
+#pragma warning ( disable : 4102 )
+#pragma warning ( disable : 4244 )
+#endif
+
+
+#line 81 "y.tab.c" /* yacc.c:339  */
+
+# ifndef YY_NULLPTR
+#  if defined __cplusplus && 201103L <= __cplusplus
+#   define YY_NULLPTR nullptr
+#  else
+#   define YY_NULLPTR 0
+#  endif
+# endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* In a future release of Bison, this section will be replaced
+   by #include "y.tab.h".  */
+#ifndef YY_YY_Y_TAB_H_INCLUDED
+# define YY_YY_Y_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    STR = 258,
+    NUM = 259,
+    FNUM = 260
+  };
+#endif
+/* Tokens.  */
+#define STR 258
+#define NUM 259
+#define FNUM 260
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 16 "config.y" /* yacc.c:355  */
+
+  char   *name;
+  int    num;
+  double fnum;
+
+#line 137 "y.tab.c" /* yacc.c:355  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+#endif /* !YY_YY_Y_TAB_H_INCLUDED  */
+
+/* Copy the second part of user declarations.  */
+
+#line 152 "y.tab.c" /* yacc.c:358  */
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#else
+typedef signed char yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE
+# if (defined __GNUC__                                               \
+      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
+     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
+#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
+# else
+#  define YY_ATTRIBUTE(Spec) /* empty */
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE_PURE
+# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+#endif
+
+#ifndef YY_ATTRIBUTE_UNUSED
+# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
+#endif
+
+#if !defined _Noreturn \
+     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
+# if defined _MSC_VER && 1200 <= _MSC_VER
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(E) ((void) (E))
+#else
+# define YYUSE(E) /* empty */
+#endif
+
+#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define YY_INITIAL_VALUE(Value) Value
+#endif
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYSIZE_T yynewbytes;                                            \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / sizeof (*yyptr);                          \
+      }                                                                 \
+    while (0)
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYSIZE_T yyi;                         \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (0)
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  5
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   11
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  8
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  3
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  6
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  13
+
+/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
+   by yylex, with out-of-bounds checking.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   260
+
+#define YYTRANSLATE(YYX)                                                \
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, without out-of-bounds checking.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     7,
+       2,     6,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5
+};
+
+#if YYDEBUG
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_uint8 yyrline[] =
+{
+       0,    28,    28,    29,    32,    33,    34
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || 0
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "STR", "NUM", "FNUM", "'='", "';'",
+  "$accept", "commands", "command", YY_NULLPTR
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[NUM] -- (External) token number corresponding to the
+   (internal) symbol number NUM (which must be that of a token).  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,    61,    59
+};
+# endif
+
+#define YYPACT_NINF -5
+
+#define yypact_value_is_default(Yystate) \
+  (!!((Yystate) == (-5)))
+
+#define YYTABLE_NINF -1
+
+#define yytable_value_is_error(Yytable_value) \
+  0
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+static const yytype_int8 yypact[] =
+{
+      -2,    -4,     0,    -5,     1,    -5,    -5,     2,     3,     4,
+      -5,    -5,    -5
+};
+
+  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+     Performed when YYTABLE does not specify something else to do.  Zero
+     means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       0,     0,     0,     3,     0,     1,     2,     0,     0,     0,
+       4,     5,     6
+};
+
+  /* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+      -5,    -5,     5
+};
+
+  /* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     2,     3
+};
+
+  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule whose
+     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_uint8 yytable[] =
+{
+       5,     1,     4,     1,     7,     8,     9,     6,     0,    10,
+      11,    12
+};
+
+static const yytype_int8 yycheck[] =
+{
+       0,     3,     6,     3,     3,     4,     5,     2,    -1,     7,
+       7,     7
+};
+
+  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,     9,    10,     6,     0,    10,     3,     4,     5,
+       7,     7,     7
+};
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,     8,     9,     9,    10,    10,    10
+};
+
+  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     2,     1,     4,     4,     4
+};
+
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+#define YYEMPTY         (-2)
+#define YYEOF           0
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                  \
+do                                                              \
+  if (yychar == YYEMPTY)                                        \
+    {                                                           \
+      yychar = (Token);                                         \
+      yylval = (Value);                                         \
+      YYPOPSTACK (yylen);                                       \
+      yystate = *yyssp;                                         \
+      goto yybackup;                                            \
+    }                                                           \
+  else                                                          \
+    {                                                           \
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;                                                  \
+    }                                                           \
+while (0)
+
+/* Error token number */
+#define YYTERROR        1
+#define YYERRCODE       256
+
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
+
+/* This macro is provided for backward compatibility. */
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Type, Value); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+
+/*----------------------------------------.
+| Print this symbol's value on YYOUTPUT.  |
+`----------------------------------------*/
+
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  FILE *yyo = yyoutput;
+  YYUSE (yyo);
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  YYUSE (yytype);
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  YYFPRINTF (yyoutput, "%s %s (",
+             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+static void
+yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
+{
+  unsigned long int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+             yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       yystos[yyssp[yyi + 1 - yynrhs]],
+                       &(yyvsp[(yyi + 1) - (yynrhs)])
+                                              );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, Rule); \
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+yystrlen (const char *yystr)
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            /* Fall through.  */
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULLPTR;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                {
+                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
+                  if (! (yysize <= yysize1
+                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                    return 2;
+                  yysize = yysize1;
+                }
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  {
+    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
+    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+      return 2;
+    yysize = yysize1;
+  }
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+{
+  YYUSE (yyvaluep);
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
+
+
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+int
+yyparse (void)
+{
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       'yyss': related to states.
+       'yyvs': related to semantic values.
+
+       Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yyssp = yyss = yyssa;
+  yyvsp = yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        YYSTYPE *yyvs1 = yyvs;
+        yytype_int16 *yyss1 = yyss;
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * sizeof (*yyssp),
+                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yystacksize);
+
+        yyss = yyss1;
+        yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+        goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
+
+      {
+        yytype_int16 *yyss1 = yyss;
+        union yyalloc *yyptr =
+          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+        if (! yyptr)
+          goto yyexhaustedlab;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+                  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = yylex ();
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     '$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 4:
+#line 32 "config.y" /* yacc.c:1646  */
+    { config_assign_string( (yyvsp[-3].name), (yyvsp[-1].name) ); free( (yyvsp[-3].name) ); free( (yyvsp[-1].name) ); }
+#line 1223 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 5:
+#line 33 "config.y" /* yacc.c:1646  */
+    { config_assign_int( (yyvsp[-3].name), (yyvsp[-1].num) ); free( (yyvsp[-3].name) ); }
+#line 1229 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 6:
+#line 34 "config.y" /* yacc.c:1646  */
+    { config_assign_float( (yyvsp[-3].name), (yyvsp[-1].fnum) ); free( (yyvsp[-3].name) ); }
+#line 1235 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+
+#line 1239 "y.tab.c" /* yacc.c:1646  */
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now 'shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+         error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
+      else
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval);
+          yychar = YYEMPTY;
+        }
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+        {
+          yyn += YYTERROR;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+        YYABORT;
+
+
+      yydestruct ("Error: popping",
+                  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined yyoverflow || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  return yyresult;
+}
+#line 37 "config.y" /* yacc.c:1906  */
+
diff --git a/intersim2/y.tab.h b/intersim2/y.tab.h
new file mode 100644
--- /dev/null
+++ b/intersim2/y.tab.h
@@ -0,0 +1,80 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison interface for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+#ifndef YY_YY_Y_TAB_H_INCLUDED
+# define YY_YY_Y_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    STR = 258,
+    NUM = 259,
+    FNUM = 260
+  };
+#endif
+/* Tokens.  */
+#define STR 258
+#define NUM 259
+#define FNUM 260
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 16 "config.y" /* yacc.c:1909  */
+
+  char   *name;
+  int    num;
+  double fnum;
+
+#line 70 "y.tab.h" /* yacc.c:1909  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+#endif /* !YY_YY_Y_TAB_H_INCLUDED  */
